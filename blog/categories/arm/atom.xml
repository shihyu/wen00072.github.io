<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arm | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/arm/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2016-08-05T14:45:53+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (2): 實驗軟體專案規劃和LED閃滅實驗]]></title>
    <link href="http://wen00072.github.io/blog/2016/06/27/arm-cm4-pratice-2-lab-led/"/>
    <updated>2016-06-27T19:14:27+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/06/27/arm-cm4-pratice-2-lab-led</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>閉著眼睛學東西最困擾的是資料很多，但是完全不知道怎麼從那邊下手。這次運氣很好終於找到大大推荐的<a href="http://homes.soic.indiana.edu/geobrown/index.cgi/teaching">入門教材: Discovering the STM32 Microcontroller</a>作為一個突破點。雖然他上面講的是STM32F1，不過改一下還是可以在開發版上面動，短期內的自學大概會以這本書為主。</p>

<p>本篇文章主要是介紹在GNU/Linux下的STM32F429　開發軟體，這次以LED閃滅為實習題目，以後的實習會基於這次的專案為主。有興趣的朋友請自行到我的<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice">Github repository</a>取用。注意是這個專案單純自爽，常常會<code>git push -f</code>變動commit，如果有人fork我再調整。</p>

<h2>目錄</h2>

<ul>
<li><a href="#STM-ENV">測試環境</a></li>
<li><a href="#STM_PRJ">專案規劃</a></li>
<li><a href="#STM_MK">Makefile撰寫</a>

<ul>
<li><a href="#STM_MK_COMM">共用變數</a></li>
<li><a href="#STM_MK_TEMP">專案Makefile template</a></li>
</ul>
</li>
<li><a href="#STM_LED">第一支程式: LED閃滅</a>

<ul>
<li><a href="#STM_LED_LK_STRP">Linker script 和 start up檔案</a></li>
<li><a href="#STM_LED_GPIO">GPIO API</a></li>
<li><a href="#STM_LED_TIMER_ISR">Timer ISR</a></li>
<li><a href="#STM_LED_CODE">程式碼</a></li>
<li><a href="#STM_LED_VERIFY">燒錄和測試</a></li>
</ul>
</li>
<li><a href="#STM-SPL-REF">參考資料</a></li>
</ul>


<p><a name="STM-ENV"></a></p>

<h2>測試環境</h2>

<pre><code class="text">$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.4 LTS
Release:    14.04
Codename:   trusty

$ arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-branch revision 237715]
...
</code></pre>

<ul>
<li>SPL版本： STM32F4xx_DSP_StdPeriph_Lib_V1.6.1</li>
<li>開發板： STM32F4 Dicovery, <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F429-Disco</a></li>
<li>SPL 目錄架構</li>
</ul>


<pre><code class="text">$ tree -d -L 4
.
└── STM32F4xx_DSP_StdPeriph_Lib_V1.6.1
    ├── _htmresc
    ├── Libraries
    │   ├── CMSIS
    │   │   ├── Device
    │   │   ├── Documentation
    │   │   ├── DSP_Lib
    │   │   ├── Include
    │   │   ├── Lib
    │   │   └── RTOS
    │   └── STM32F4xx_StdPeriph_Driver
    │       ├── inc
    │       └── src
    ├── Project
    │   ├── STM32F4xx_StdPeriph_Examples
    │   └── STM32F4xx_StdPeriph_Templates
    └── Utilities
        ├── Media
        ├── ST
        ├── STM32_EVAL
        └── Third_Party
</code></pre>

<p><a name="STM_PRJ"></a></p>

<h2>專案規劃</h2>

<p>看<a href="http://www.cs.indiana.edu/~geobrown/book.pdf">Discovering the STM32 Microcontroller</a>這本書後啟發的。想法整理如下：</p>

<ul>
<li>目的：建立一個練習STM32F4開發版的專案</li>
<li>專案需要的資料

<ul>
<li>STM 函式庫 source code

<ul>
<li>這部份要去官方網站下載，不會放到github上面</li>
</ul>
</li>
<li>Build code 共用的設定如toolchain、路徑、compile flag等</li>
<li>一些template 檔案加入開發如Makefile、linker script、config header file</li>
</ul>
</li>
</ul>


<p>最後的目錄就是這樣。</p>

<pre><code class="text ">$ tree -L 3
.
├── conf
│   ├── build.def
│   ├── Makefile.template
│   ├── stm32f4xx_conf.h
│   └── template-bared.ld
├── labs
│   └── 0_led
│       ├── led.c
│       ├── led.ld
│       ├── Makefile
│       └── stm32f4xx_conf.h
├── libraries
│   ├── readme.txt
│   └── STM32F4xx_DSP_StdPeriph_Lib_V1.6.1
├── LICENSE
└── README.md
</code></pre>

<p>請注意SPL可能會因為下載版本不同，變數宣告、常數宣告、和檔案名稱路徑可能不同造成編譯失敗，這時候就當組裝作業自己解決吧。</p>

<p><a name="STM_MK"></a></p>

<h2>Makefile撰寫</h2>

<p><a name="STM_MK_COMM"></a></p>

<h3>共用變數</h3>

<p>這邊我們需要一個共用的設定，在實習的時候直接include。詳細說明如下，懶得看的可以直接看<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/conf/build.def">檔案內容</a>。</p>

<ul>
<li><p>Toolchain設定</p>

<ul>
<li>安裝請參考<a href="http://wen00072.github.io/blog/2016/04/06/arm-cm4-pratice-0-environment-setup/">這邊</a>
<code>Makefile
TOOL_CHAIN_PREFIX=arm-none-eabi
</code></li>
</ul>
</li>
<li><p>路徑設定</p>

<ul>
<li>我們需要<strong>定位</strong>專案的最頂端位址才能設定其他路徑的相對位址</li>
<li>除了您自己的檔案，ST 提供的函式庫和ARM的CMSIS在開發都會用到</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">PRJ_ROOT?=..
LIB_DIR=$(PRJ_ROOT)/libraries/STM32F4xx_DSP_StdPeriph_Lib_V1.6.1/Libraries
STM_DIR=$(LIB_DIR)/STM32F4xx_StdPeriph_Driver
CMSIS_DIR=$(LIB_DIR)/CMSIS
LDSCRIPT?=$(PRJ_ROOT)/conf/bared.ld
</code></pre>

<ul>
<li><p>指定開發平台
<code>Makefile
PLATFORM = STM32F429_439xx
</code></p></li>
<li><p>設定header file路徑
<code>Makefile
SPL_INC=$(STM_DIR)/inc
CMSIS_COMMON_INC = $(CMSIS_DIR)/Include
CMSIS_STM32_INC  = $(CMSIS_DIR)/Device/ST/STM32F4xx/Include
</code></p></li>
<li><p>指令所有產生的檔案都放到build目錄
<code>Makefile
OUT_DIR=$(PRJ_ROOT)/build
</code></p></li>
<li><p>設定start up檔案和system檔案路徑
除非你要自己從flash搬資料到RAM、設定ISR vector、RCC等，不然一定會用到start up 檔案和system檔案。start up 檔案在SPL中有很多範本，我們使用了<code>gcc_ride7</code>這個版本，原因是其他的都沒有<code>gcc</code>這個字眼。
<code>Makefile
CMSIS_STARTUP_SRC = $(CMSIS_DIR)/Device/ST/STM32F4xx/Source/Templates/gcc_ride7/startup_stm32f429_439xx.s
CMSIS_SYSTEM_SRC  = $(CMSIS_DIR)/Device/ST/STM32F4xx/Source/Templates/system_stm32f4xx.c
</code></p></li>
<li><p>設定debug mode
SPL提供assertion，使用USE_FULL_ASSERT打開。打開以後需要自行實作函數<code>void assert_failed(uint8_t* file, uint32_t line)</code>。</p></li>
</ul>


<pre><code class="Makefile">BUILD_MODE = DEBUG

ifeq ($(BUILD_MODE), DEBUG)
        CFLAGS += -DUSE_FULL_ASSERT -g3
endif
</code></pre>

<ul>
<li><p>CPU相關compile flags
STM32F4使用Cotex M4。題外話，對於toolchain有興趣的可以用<code>arm-none-eabi-gcc -Q --help=target</code>查詢有支援哪些平台。
<code>Makefile
ARCH_FLAGS = -mthumb -mcpu=cortex-m4
</code></p></li>
<li><p>Compile flag分為</p>

<ul>
<li>增加嚴格的錯誤檢查</li>
<li>設定include 路徑</li>
<li>叫toolchain不要用使用內建的函式庫如libc</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">LDFLAGS += -T$(LDSCRIPT) $(ARCH_FLAGS)

CFLAGS += $(ARCH_FLAGS)
CFLAGS += -I. -I$(SPL_INC) -I$(CMSIS_COMMON_INC) -I$(CMSIS_STM32_INC)
CFLAGS += -D$(PLATFORM) -DUSE_STDPERIPH_DRIVER $(FULLASSERT)
CFLAGS += -Wall -Werror -MMD -std=c99
CFLAGS += -fno-common -ffreestanding -O0
</code></pre>

<p><a name="STM_MK_TEMP"></a></p>

<h3>專案Makefile template</h3>

<p>這邊直接把LED閃滅的Makefile拿來當template，詳細說明如下，一樣懶得看的可以去<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/conf/Makefile.template">這邊</a>看檔案內容。</p>

<ul>
<li>產生的binary 檔名、定位專案的最頂端位址、並且載入<a href="#STM_MK_COMM">前面</a>的設定檔。</li>
</ul>


<pre><code class="Makefile">TARGET=led
PRJ_ROOT=$(shell cd ../../ ; pwd)
include $(PRJ_ROOT)/conf/build.def
</code></pre>

<ul>
<li><p>指定要編譯的SPL 檔案
除了前面<a href="#STM_MK_COMM">前面</a>提到的start up檔案、system檔、還有你自己的程式碼外，根據你的需求，還會需要SPL的驅動程式。這個專案我們需要<code>GPIO</code>和<code>RCC</code> (reset clock control)這兩個部份。一個是用來控制LED、另外一個用來計算時間產生以控制閃滅。
<code>Makefile
SRCS  = $(CMSIS_STARTUP_SRC) $(CMSIS_SYSTEM_SRC)
SRCS += $(STM_DIR)/src/stm32f4xx_gpio.c
SRCS += $(STM_DIR)/src/stm32f4xx_rcc.c
SRCS += led.c
</code></p></li>
<li><p>檔名轉換
上面的是source檔案，但是我們編譯需要把source檔案轉成object檔案並且存在./build目錄下。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Makefile'><span class='line'><span class="nv">C_OBJS</span> <span class="o">=</span> <span class="k">$(</span>patsubst %.c, %.o, <span class="k">$(</span>SRCS<span class="k">))</span>   <span class="c"># translate &lt;em&gt;.c to &lt;/em&gt;.o</span>
</span><span class='line'><span class="nv">OBJS</span>   <span class="o">=</span> <span class="k">$(</span>patsubst %.s, %.o, <span class="k">$(</span>C_OBJS<span class="k">))</span> <span class="c"># also &lt;em&gt;.s to &lt;/em&gt;.o files&lt;/p&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="err">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span><span class="nv">OUT_OBJS</span> <span class="o">=</span> <span class="k">$(</span>addprefix <span class="k">$(</span>OUT_DIR<span class="k">)</span>/, <span class="k">$(</span>OBJS<span class="k">))</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>產生led.bin
不要被符號嚇到，說明如下</p>

<ul>
<li>產生build/led.bin檔，前提是上面的object 檔案都編譯完成</li>
<li>產生方式

<ul>
<li>叫gcc 從前面的object檔案中，透過led.ld linker script產生出build/led.elf、build/led.map (debug用)</li>
<li>從build/led.elf產生build/led.bin</li>
<li>從build/led.elf產生build/led.list (debug用)</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">$(OUT_DIR)/$(TARGET).bin: $(OUT_OBJS)
    $(TOOL_CHAIN_PREFIX)-gcc -Wl,-Map=$(OUT_DIR)/$(TARGET).map,-T$(TARGET).ld -nostartfiles \
        $(CFLAGS) $(OUT_OBJS) -o $(OUT_DIR)/$(TARGET).elf
    $(TOOL_CHAIN_PREFIX)-objcopy -Obinary $(OUT_DIR)/$(TARGET).elf $@
    $(TOOL_CHAIN_PREFIX)-objdump -S $(OUT_DIR)/$(TARGET).elf &gt; $(OUT_DIR)/$(TARGET).list
</code></pre>

<ul>
<li>編譯並產生object 檔案
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Makefile'><span class='line'><span class="nf">$(OUT_DIR)/%.o</span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>  @mkdir -p <span class="k">$(</span>dir <span class="nv">$@</span><span class="k">)</span>
</span><span class='line'>  <span class="k">$(</span>TOOL_CHAIN_PREFIX<span class="k">)</span>-gcc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&amp;</span>lt<span class="p">;</span> -o <span class="nv">$@</span>&lt;/li&gt;
</span><span class='line'><span class="err">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;p&gt;$(OUT_DIR)/%.o</span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    @mkdir -p <span class="k">$(</span>dir <span class="nv">$@</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>TOOL_CHAIN_PREFIX<span class="k">)</span>-gcc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&amp;</span>lt<span class="p">;</span> -o <span class="nv">$@</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>以下不解釋
<code>Makefile
clean:
  rm -fr $(OUT_DIR) gdb.txt
</code></li>
</ul>


<p><a name="STM_LED"></a></p>

<h2>第一支程式: LED閃滅</h2>

<p><a name="STM_LED_LK_STRP"></a></p>

<h3>Linker script 和 start up檔案</h3>

<h4>Linker script</h4>

<p>linker script (<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/labs/0_led/led.ld">全文</a>)，這個script是從<a href="http://wiki.csie.ncku.edu.tw/embedded/rtenv">成大課程作業</a>修改的，簡單解釋如下</p>

<ul>
<li>有兩塊記憶體，一個是FLASH一個是RAM，FLASH 不可寫入。</li>
<li>那些<code>.text</code>、<code>.data</code>、<code>.bss</code>就不解釋了。我們這次關注下列的symbols

<ul>
<li><code>_sidata</code></li>
<li><code>_sdata</code></li>
<li><code>_edata</code></li>
<li><code>_sbss</code></li>
<li><code>_ebss</code></li>
<li><code>_estack</code></li>
</ul>
</li>
</ul>


<h4>Start up檔案</h4>

<p>上面的這些symbol，可以<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S">對照</a>這邊的start up 程式碼中的<code>reset_handler</code>，可以發現：</p>

<ul>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L49">第49行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L57">第57行</a>就宣告了這些symbol</li>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L76">第76行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L89">第89行</a>使用了這些symbol將FLASH中的<code>.data</code>資料搬到<code>RAM</code>中</li>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L89">第90行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L100">第100行</a>使用了這些symbol將<code>.bss</code>區段的值全部設成0</li>
</ul>


<p>搞定<code>.bss</code>和<code>.data</code>後，接下來start up會去<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L103">呼叫systemInit</a>，而<code>systemInit</code>就在<code>system_stm32f4xx.c</code>裏面。設定完系統後就是你寫的程式碼<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L105">main</a>上場了。</p>

<p>start up 檔案剩下的部份就是<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L128">.isr_vector</a>，可以想像成一個function pointer陣列(除了最開始的stack pointer，注意stack pointer初始值也是在linker script中設定的)。</p>

<p>另外一個要注意的是start up source code的順序和放在記憶體的順序不一致，真正在記憶體的順序請參考<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/labs/0_led/led.ld">linker script</a>。
<a name="STM_LED_GPIO"></a></p>

<h3>GPIO API</h3>

<p>設定順序如下</p>

<ul>
<li>看<a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">開發版手冊</a>找出要控制燈號的GPIO

<ul>
<li>我程式就是輪流點亮點滅LED 3和LED 4，手冊上說是GPIO G的第13和14腳位</li>
</ul>
</li>
<li>打開GPIO的clock（猜測嵌入式系統的電耗考慮，沒再用的設備都不開clock省電）</li>
<li>設定GPIO腳位的為輸出頻率為2MHz</li>
</ul>


<pre><code class="c GPIO設定">void setupLED(GPIO_InitTypeDef *LED_InitStruct)
{
    /* Setup LED GPIO */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);

    GPIO_StructInit(LED_InitStruct);
    LED_InitStruct-&gt;GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_14 ;
    LED_InitStruct-&gt;GPIO_Mode  = GPIO_Mode_OUT;
    LED_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_Init(GPIOG, LED_InitStruct);
}
</code></pre>

<ul>
<li>輸出資料到GPIO範例如下
<code>c 輸出資料到GPIO範例
  GPIO_WriteBit(GPIOG, GPIO_Pin_13 , 1);
</code></li>
</ul>


<p><a name="STM_LED_TIMER_ISR"></a></p>

<h3>Timer ISR</h3>

<p>要做的是</p>

<ul>
<li><p>設定timer interrupt 出現的週期，設定成nano second的程式碼如下
<code>c
  /* Setup timer interrupt interval to nano second */
  if(SysTick_Config(SystemCoreClock / 1000)) {
      while(1); /* Trap here if failed */
  }   
</code></p></li>
<li><p>time out的ISR，基本上就是計數counter加上busy waiting而已
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">__IO</span> <span class="kt">uint32_t</span> <span class="n">g_timeToWakeUp</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">sleep</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">nSec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">g_timeToWakeUp</span> <span class="o">=</span> <span class="n">nSec</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Busy</span> <span class="n">waiting</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">g_timeToWakeUp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<p><a name="STM_LED_CODE"></a></p>

<h3>程式碼</h3>

<p>這邊的assertion 實作單純是一個無限迴圈，當assertion失敗就會陷入這個迴圈。這時候用除錯器就可以找到出現assertion的行號了。</p>

<p>寫了以後開始修改程式碼或<code>Makefile</code>直到編譯過以後才針對程式行為除錯。</p>

<pre><code class="c led.c">#include "stm32f4xx_conf.h"
#include &lt;stm32f4xx.h&gt;
#include &lt;stm32f4xx_gpio.h&gt;

/* A Led blink lab for STM32 Discovry Disco                   *
 * Based on:                                                  *
 *   Discovering the STM32 Microcontroller by Geoffrey Brown. */

void setupLED(GPIO_InitTypeDef *LED_InitStruct);
void sleep(uint32_t nSec);

int main(int argc, char **argv)
{
    static int LEDVal = 0;
    GPIO_InitTypeDef LED_InitStruct;

    /* Setup LED */
    setupLED(&amp;LED_InitStruct);

    /* Setup timer interrupt interval to nano second */
    if(SysTick_Config(SystemCoreClock / 1000)) {
        while(1); /* Trap here if failed */
    }

    /* Blinking LED3 and LED4 */
    while(1) {
        GPIO_WriteBit(GPIOG, GPIO_Pin_13 , LEDVal);
        GPIO_WriteBit(GPIOG, GPIO_Pin_14 , !LEDVal);

        sleep(250);
        LEDVal = !LEDVal;
    }

    return 0;
}

void setupLED(GPIO_InitTypeDef *LED_InitStruct)
{
    /* Setup LED GPIO */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);

    GPIO_StructInit(LED_InitStruct);
    LED_InitStruct-&gt;GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_14 ;
    LED_InitStruct-&gt;GPIO_Mode  = GPIO_Mode_OUT;
    LED_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_Init(GPIOG, LED_InitStruct);
}

static __IO uint32_t g_timeToWakeUp;
void sleep(uint32_t nSec)
{
    g_timeToWakeUp = nSec;

    /* Busy waiting */
    while(g_timeToWakeUp != 0);
}

/* ISR for system tick */
void SysTick_Handler(void)
{
    if (g_timeToWakeUp != 0x00) {
        g_timeToWakeUp--;
    }
}

/* Trap here for gdb if asserted */
void assert_failed(uint8_t* file, uint32_t line)
{
    while(1);
}
</code></pre>

<p>比較有趣的是<code>int LEDVal = 0;</code>一定要宣告成<code>static</code>，否則LED完全沒反應。在網路上請教似乎和進出ISR的時候context備份有關係，這部份有空再找時間了解一下，這次先跳過。</p>

<ul>
<li>更新，後來測試不管是沒有<code>static</code>，把<code>static</code>改成<code>volatile</code>，都出現第一次燒錄行為不正常，多燒幾次又正常的情況。需要再重新釐清。</li>
</ul>


<p><a name="STM_LED_VERIFY"></a></p>

<h3>燒錄和測試</h3>

<ul>
<li><p>直接在工作目錄下執行make
<code>text
STM32F429-Discovery-Disco-Pratice/labs/0_led$ make
arm-none-eabi-gcc -c -DUSE_FULL_ASSERT -g3 -mthumb -mcpu=cortex-m4 -I. -I../../libraries/STM32F4xx_DSP_StdPeriph_Lib_V1.6.1/Libraries/STM32F4xx_StdPeriph_Driver/inc -I../../libraries/
...
arm-none-eabi-objcopy -Obinary ../../build/led.elf ../../build/led.bin
arm-none-eabi-objdump -S ../../build/led.elf &gt; ../../build/led.list
</code></p></li>
<li><p>燒錄指令如下
<code>text
STM32F429-Discovery-Disco-Pratice/labs/0_led$ st-flash write ../../build/led.bin  0x8000000
2016-07-25T11:31:28 INFO src/stlink-common.c: Loading device parameters....
2016-07-25T11:31:28 INFO src/stlink-common.c: Device connected is: F42x and F43x device, id 0x10036419
...
enabling 32-bit flash writes
size: 11596
2016-07-25T11:31:28 INFO src/stlink-common.c: Starting verification of write complete
2016-07-25T11:31:29 INFO src/stlink-common.c: Flash written and verified! jolly good!
</code></p></li>
</ul>


<p>以下是LED點亮結果</p>

<center><img src="http://wen00072.github.io/files/stm32/STM_LED.jpg"></img></center>


<p><a name="STM-SPL-REF"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://homes.soic.indiana.edu/geobrown/index.cgi/teaching">Geoffrey Brown: Teaching </a>

<ul>
<li>請找 Lab Manual 裏面的link, 書名是<code>Discovering the STM32 Microcontroller</code></li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F4 Discovry Disco 開發版手冊</a></li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">STM32F4 DSP and standard peripherals library</a></li>
<li><a href="http://regalis.com.pl/en/arm-cortex-stm32-gnulinux/">Programming ARM Cortex (STM32) under GNU/Linux</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (1): STM32 F4xx Standard Peripherals Library手冊整理]]></title>
    <link href="http://wen00072.github.io/blog/2016/06/25/stm32-f4xx-standard-peripherals-libraryshou-ce-zheng-li/"/>
    <updated>2016-06-25T14:03:46+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/06/25/stm32-f4xx-standard-peripherals-libraryshou-ce-zheng-li</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>以前在寫作業的時候，從來沒有想過那些週邊到底怎麼使用，只大概印象和<a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a>有關。後來想應該是要去了解到底這些廠商提供的函式庫在軟體開發中扮演了什麼樣的角色？因此花了時間整理如下。</p>

<p>在使用之前，請自行到<a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">官方網站</a>下載STM32F4 DSP and standard peripherals library。</p>

<h2>目錄</h2>

<ul>
<li><a href="#AST-%E7%B0%A1%E4%BB%8B">簡介</a>

<ul>
<li><a href="#AST-CMSIS">CMSIS和Standard Peripherals Library說明</a></li>
</ul>
</li>
<li><a href="#AST-Rules">Coding rules and conventions</a>

<ul>
<li><a href="#AST-Rules-general">一般命名規則</a></li>
<li><a href="#AST-Rules-reg">週邊 Register 命名規則</a></li>
</ul>
</li>
<li><a href="#AST-Ref">參考資料</a></li>
</ul>


<p><a name="AST-簡介"></a></p>

<h2>簡介</h2>

<p>手冊上提到Standard Peripherals Library (以下簡稱SPL)的特點</p>

<ul>
<li>提供STM32F4 XX的週邊驅動程式和常用的資料結構</li>
<li>基於CMSIS開發</li>
<li>ANSI C開發</li>
<li>使用SPL表示週邊設備存取效能和佔用的記憶體空間是由SPL決定，因此有特別限制的話必須要自行最佳化或是實作</li>
</ul>


<p>SPL包含:</p>

<ul>
<li>週邊設備暫存器的位址mapping，包含這些暫存器的bit</li>
<li>所有週邊的控制function以及對應的資料結構</li>
<li>範例程式</li>
</ul>


<p><a name="AST-CMSIS"></a></p>

<h3>CMSIS和Standard Peripherals Library說明</h3>

<p>整體的架構圖如下(參考手冊資料）</p>

<center><img src="http://wen00072.github.io/files/stm32/SPL_Diag.jpg"></img></center>


<p>簡單說明如下</p>

<ul>
<li>CMSIS 提供了

<ul>
<li>統一的暫存器定義、位址定義</li>
<li>協助開發的函數</li>
<li>RTOS 介面</li>
<li>DSP 相關函數</li>
</ul>
</li>
<li>開發版上實體的週邊驅動程式是透過SPL和CMSIS來控制硬體</li>
</ul>


<p><a name="AST-Rules"></a></p>

<h2>Coding rules and conventions</h2>

<p><a name="AST-Rules-general"></a></p>

<h3>一般命名規則</h3>

<ul>
<li>函數名稱以<strong>大寫週邊簡寫</strong>為prefix如<code>USART_SendData</code></li>
<li>文件舉例的API，請自行望文生義

<ul>
<li><code>週邊名稱_Init</code></li>
<li><code>週邊名稱_DeInit</code></li>
<li><code>週邊名稱_StructInit</code></li>
<li><code>週邊名稱_Cmd</code></li>
<li><code>週邊名稱_ITConfig</code>

<ul>
<li>IT: interrupt</li>
</ul>
</li>
<li><code>週邊名稱_DMAConfig</code></li>
<li><code>週邊名稱_XXXConfig</code>

<ul>
<li>週邊設備的XXX設定</li>
</ul>
</li>
<li><code>週邊名稱_GetFlagStatus</code></li>
<li><code>週邊名稱_ClearFlag</code></li>
<li><code>週邊名稱_ClearITPendingBit</code></li>
</ul>
</li>
</ul>


<p><a name="AST-Rules-reg"></a></p>

<h3>週邊 Register 命名規則</h3>

<ul>
<li>週邊 Register 一律包裝在<code>struct</code>中，名稱一律為大寫。在 stm32f4xx.h 另外已經宣告了週邊設備位址的結構如：</li>
</ul>


<pre><code class="c">#define SPI1                  ((SPI_TypeDef *) SPI1_BASE)
</code></pre>

<p><code>SPI_TypeDef</code>為一個struct，因此你可以使用下面方式直接存取週邊設備暫存器。</p>

<pre><code class="c">SPI1-&gt;CR1 = 0x0001;
</code></pre>

<p>有了大概概念後，接下來就是開幹時間，敬請期待。</p>

<p><a name="AST-Ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">STM32F4 DSP and standard peripherals library</a>

<ul>
<li>本篇絕大部分參考解開套件後的stm32f4xx_dsp_stdperiph_lib_um.chm　這個文件檔案</li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-embedded-software/stm32cubef4.html">STM32CubeF4網頁</a>

<ul>
<li>有SPL的相關資料</li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32062.html">STM32F2 standard peripherals library手冊</a>

<ul>
<li>交叉比對用</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (0): Environment Setup]]></title>
    <link href="http://wen00072.github.io/blog/2016/04/06/arm-cm4-pratice-0-environment-setup/"/>
    <updated>2016-04-06T22:15:15+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/04/06/arm-cm4-pratice-0-environment-setup</id>
    <content type="html"><![CDATA[<p>很久以前買了<a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF259090">STM32F4 Disco的開發版</a>（<a href="http://wiki.csie.ncku.edu.tw/embedded/STM32F429">繁體中文資訊</a>），最近開始想要學習ARM架構和硬體控制等技術。在設定目標，規劃進度前，一定要先把編譯和燒錄環境架設起來，整理如下：</p>

<h2>目錄</h2>

<ul>
<li><a href="#cm4-0-env">安裝作業系統環境</a></li>
<li><a href="#cm4-0-steps">安裝步驟</a>

<ul>
<li><a href="#cm4-0-steps-tl">安裝Toolchain</a></li>
<li><a href="#cm4-0-steps-pkg-install">手動安裝燒錄和除錯工具</a>

<ul>
<li><a href="#cm4-0-steps-pkg-install-prepare">安裝需要套件</a></li>
<li><a href="#cm4-0-steps-pkg-install-stlink">手動安裝st-link</a></li>
<li><a href="#cm4-0-steps-pkg-install-openocd">手動安裝OpenOCD</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cm4-0-test">驗證燒錄</a>

<ul>
<li><a href="#cm4-0-test-prepare">事前準備</a></li>
<li><a href="#cm4-0-test-stflash">使用st-flash 開發版燒錄</a></li>
<li><a href="#cm4-0-test-openocd">使用openocd 開發版燒錄</a></li>
</ul>
</li>
<li><a href="#cm4-0-ref">參考資料</a></li>
</ul>


<p><a name="cm4-0-env"></a></p>

<h2>安裝作業系統環境</h2>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.4 LTS
Release:    14.04
Codename:   trusty
</code></pre>

<p><a name="cm4-0-steps"></a></p>

<h2>安裝步驟</h2>

<p>要開發非本機的平台，我們會需要安裝</p>

<ul>
<li>Toolchain：提供編譯，函數，分析binary等功能</li>
<li>燒錄軟體</li>
<li>除錯工具</li>
</ul>


<p>st-link和openocd同時有燒錄和開發版軟體除錯的功能，因此我們兩個都安裝。</p>

<p><a name="cm4-0-steps-tl"></a></p>

<h3>安裝Toolchain</h3>

<p>網路上找到<a href="https://launchpad.net/gcc-arm-embedded">GCC ARM Embedded (ARM R和M系列使用 )</a>的PPA。簡單找一下網路，<strong><font color="red">沒有直接證據說這邊的PPA是由ARM官方維護</font></strong>。不過在<a href="http://yottadocs.mbed.com/#installing-on-linux">mbed(ARM 成立的IoT作業系統)網站裏面</a>的確有提到這個PPA，暫時當作間接證據。<strong><font color="red">目前我還沒有驗證這個Toolchain編譯出來的binary是否可以在開發版上正常動作</font></strong>。</p>

<pre><code class="text 安裝Toolchain指令">sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa
sudo apt-get update
sudo apt-get install gcc-arm-embedded
</code></pre>

<p><a name="cm4-0-steps-pkg-install"></a></p>

<h3>手動安裝燒錄和除錯工具</h3>

<p><a name="cm4-0-steps-pkg-install-prepare"></a></p>

<h4>安裝需要套件</h4>

<pre><code class="text 系統安裝設定STM32F4環境相關套件 ">sudo apt-get install git
sudo apt-get install libtool
sudo apt-get install automake
sudo apt-get install autoconf
sudo apt-get install pkg-config
sudo apt-get install libusb-1.0-0-dev
sudo apt-get install libftdi-dev   # 當openocd要支援MPSSE mode才需要裝，這是啥我不知道。
sudo apt-get install libhidapi-dev # 當openocd要支援CMSIS-DAP才會用到，這是啥我不知道。
</code></pre>

<p>我自己的習慣是非必要不會放在系統中，<strong>接下來的指令都是預設<code>st-link</code>和<code>openocd</code>裝到<code>$HOME/bin</code>中</strong>，Ubuntu在登入時會自動將<code>~/bin</code>加入<code>PATH</code>中。</p>

<p>如果您沒有~/bin的話，請使用下面指令建立。
<code>
mkdir ~/bin/
. ~/.profile # 強迫系統自動將`~/bin`加入`PATH`中
</code></p>

<p><a name="cm4-0-steps-pkg-install-stlink"></a></p>

<h4>手動安裝st-link</h4>

<p>簡單講一下，就是下載、編譯、安裝軟體。特別要注意的是，為了要讓你的PC在使用Mini USB連到開發版後能夠讓Ubuntu的<code>udev</code>服務可以順利地偵測到開發版，需要加入相關設定並重新啟動<code>udev</code>服務。</p>

<p>下載Source code
<code>text 下載Source code  
git clone https://github.com/texane/stlink
</code></p>

<p>編譯stlink
<code>text 編譯
cd stlink/
./autogen.sh
./configure
make
cp st-* ~/bin
</code></p>

<p>設定並重新起動udev
<code>text 設定並重新起動udev
sudo cp 49-stlinkv* /etc/udev/rules.d/ -rv
sudo service udev restart
</code></p>

<p>驗證一下是否可以偵測到開發版，請確定測試前開發版已經和您的電腦透過Mini USB連線，以及有設定<code>udev</code>並且重新啟動。</p>

<pre><code class="text   ">$ st-probe 
Found 1 stlink programmers
30303030303030303030303100
     flash: 2097152 (pagesize: 16384)
      sram: 262144
    chipid: 0x0419
     descr: F42x and F43x device
</code></pre>

<p><a name="cm4-0-steps-pkg-install-openocd"></a></p>

<h4>手動安裝OpenOCD</h4>

<p>下載Source code
<code>text 下載Source code
git clone git://git.code.sf.net/p/openocd/code openocd-code
</code></p>

<p>編譯
<code>text 編譯
cd openocd-code/
./bootstrap
./configure # script會自動偵測系統是否有相依開發套件
make
</code></p>

<p>安裝
<code>text 安裝
cp src/openocd ~/bin
cp tcl/board/stm32f429discovery.cfg ~/.openocd/openocd.cfg
cp tcl/* ~/.openocd
</code></p>

<p>驗證一下是否可以偵測到開發版，請確定測試前開發版已經和您的電腦透過Mini USB連線。</p>

<pre><code class="text">$ openocd 
Open On-Chip Debugger 0.10.0-dev-00250-g9c37747 (2016-04-07-22:20)
Licensed under GNU GPL v2
For bug reports, read
    http://openocd.org/doc/doxygen/bugs.html
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
adapter speed: 2000 kHz
adapter_nsrst_delay: 100
none separate
srst_only separate srst_nogate srst_open_drain connect_deassert_srst
Info : Unable to match requested speed 2000 kHz, using 1800 kHz
Info : Unable to match requested speed 2000 kHz, using 1800 kHz
Info : clock speed 1800 kHz
Info : STLINK v2 JTAG v17 API v2 SWIM v0 VID 0x0483 PID 0x3748
Info : using stlink api v2
Info : Target voltage: 2.862887
Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>

<p><a name="cm4-0-test"></a></p>

<h2>驗證燒錄</h2>

<p><a name="cm4-0-test-parepare"></a></p>

<h3>事前準備</h3>

<p>下載jserv整理的STM 軔體
<code>
git clone https://github.com/jserv/stm32f429-demos
</code></p>

<p>將source中的hex轉成binary
<code>
cd stm32f429-demos/
make
</code></p>

<p>使用下載提供的Makefile燒錄，裏面會先用openocd燒錄，失敗的話自動切到st-flash燒錄，非常建議讀一下Makefile。
<code>
make flash-demo檔案
</code></p>

<p>目前套件內蒐集的demo檔案</p>

<ul>
<li>flash-GamesInJava</li>
<li>flash-STM32F429I-DISCOVERY_Demo_V1.0.1</li>
<li>flash-Paint</li>
<li>flash-TouchGFX-demo2014</li>
<li>flash-STM32CubeDemo_STM32F429I-Discovery</li>
</ul>


<p><a name="cm4-0-test-stflash"></a></p>

<h3>使用st-flash 開發版燒錄</h3>

<ul>
<li><code>st-flash write 軔體binary檔案名稱 0x8000000</code></li>
</ul>


<p>為什麼是<code>0x800000</code>呢？可以查一下<a href="http://www.st.com/web/en/resource/technical/document/datasheet/DM00071990.pdf">手冊</a>，上面有說這塊記憶體是分配給flash memory。</p>

<p><a name="cm4-0-test-openocd"></a></p>

<h4>使用openocd 開發版燒錄</h4>

<p>從<a href="https://github.com/jserv/stm32f429-demos">GitHub: jserv/stm32f429-demos</a>裏面的Makefile抄來的。指令比較長，不過這是因為openocd可以把一系列的命令連發的關係</p>

<pre><code>openocd -f interface/stlink-v2.cfg  -f target/stm32f4x.cfg  -c "init"  -c "reset init"  -c "stm32f2x unlock 0"  -c "flash probe 0"  -c "flash info 0"  -c "flash write_image erase 軔體binary檔案名稱 0x8000000"  -c "reset run" -c shutdown
</code></pre>

<p>使用比較好看的排版
<code>
openocd -f interface/stlink-v2.cfg  \
        -f target/stm32f4x.cfg      \
        -c "init"                   \
        -c "reset init"             \
        -c "stm32f2x unlock 0"      \
        -c "flash probe 0"          \
        -c "flash info 0"           \
        -c "flash write_image erase 軔體binary檔案名稱 0x8000000" \
        -c "reset run" -c shutdown
</code></p>

<h4>參數說明</h4>

<ul>
<li><code>-f</code>

<ul>
<li>指定config檔案。你可能會想問說interface目錄在那邊，還記得<a href="cm4-0-steps-pkg-install-openocd">前面</a>的動作嘛？</li>
<li>可以指定

<ul>
<li>interface: 除錯使用的介面</li>
<li>target: 執行的平台CPU如STM32F4</li>
<li>board: 開發版</li>
</ul>
</li>
</ul>
</li>
<li><code>-c</code>

<ul>
<li>執行openocd指令</li>
</ul>
</li>
</ul>


<h4>指令說明</h4>

<ul>
<li><code>-f interface/stlink-v2.cfg</code></li>
<li><code>-f target/stm32f4x.cfg</code></li>
<li><code>-c "init"</code>

<ul>
<li>結束config stage，開始進入run stage (<a href="http://openocd.org/doc/html/Daemon-Configuration.html#Entering-the-Run-Stage">出處</a>)</li>
</ul>
</li>
<li><code>-c "reset init"</code>

<ul>
<li>reset 開發版，重新開機(<a href="http://openocd.org/doc/html/General-Commands.html#Target-State-handling">出處</a>)後進入init狀態。</li>
</ul>
</li>
<li><code>-c "stm32f2x unlock 0"</code>

<ul>
<li>將開發版的flash解鎖(<a href="http://openocd.org/doc/html/Flash-Commands.html#Flash-Configuration-Commands">出處</a>)</li>
</ul>
</li>
<li><code>-c "flash probe 0"</code>

<ul>
<li>偵測開發版的flash(<a href="http://openocd.org/doc/html/Flash-Commands.html#Flash-Configuration-Commands">出處</a>)</li>
</ul>
</li>
<li><code>-c "flash info 0"</code>

<ul>
<li>顯示開發版的flash資訊(<a href="http://openocd.org/doc/html/Flash-Commands.html#Flash-Configuration-Commands">出處</a>)</li>
</ul>
</li>
<li><code>-c "flash write_image erase 軔體binary檔案名稱 0x8000000"</code>

<ul>
<li>將檔案寫入flash(<a href="http://openocd.org/doc/html/Flash-Commands.html#Flash-Configuration-Commands">出處</a>)</li>
</ul>
</li>
<li><code>-c "reset run" -c shutdown</code>

<ul>
<li>正常重新開機(<a href="http://openocd.org/doc/html/General-Commands.html#Target-State-handling">出處</a>)</li>
</ul>
</li>
</ul>


<p><a name="cm4-0-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://yottadocs.mbed.com/#installing-on-linux">yotta Documentation: Install on Linux</a></li>
<li><a href="https://launchpad.net/gcc-arm-embedded">ARM Embedded PPA網站</a></li>
<li><a href="https://launchpad.net/~team-gcc-arm-embedded/+archive/ubuntu/ppa">GNU ARM Embedded Toolchain</a></li>
<li><a href="https://github.com/jserv/stm32f429-demos">GitHub: jserv/stm32f429-demos</a></li>
<li><a href="http://openocd.org/doc/html/">OpenOCD手冊</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[關於GNU Inline Assembly]]></title>
    <link href="http://wen00072.github.io/blog/2015/12/10/about-inline-asm/"/>
    <updated>2015-12-10T22:16:49+08:00</updated>
    <id>http://wen00072.github.io/blog/2015/12/10/about-inline-asm</id>
    <content type="html"><![CDATA[<p>以前稍微接觸過GNU Inline Assembly，對於那些奇怪的符號總是覺得匪夷所思。這次找時間把他整理一下。雖然釐清了一些觀念，不過卻產生更多的疑惑，也許以後有機會看到範例會慢慢有感覺吧。</p>

<h2>目錄</h2>

<ul>
<li><a href="#ia-preface">前言</a></li>
<li><a href="#ia-env">測試環境</a></li>
<li><a href="#ia-syntax">語法</a>

<ul>
<li><a href="#ia-output">Output operands</a></li>
<li><a href="#ia-input">Input operands</a></li>
<li><a href="#ia-clo-reg">Clobbered registers list</a></li>
<li><a href="#ia-constr">Constraints</a></li>
</ul>
</li>
<li><a href="#ia-ref">參考資料</a></li>
</ul>


<p><a name="ia-preface"></a></p>

<h2>前言</h2>

<p>我自己對於GNU Inline Assembly的看法。</p>

<ul>
<li>編譯器 夠聰明，所以暫存器分配可以安心交給編譯器處理。也就是說語法上面要處理這塊。</li>
<li>暫存器、變數有些資訊仍然要讓編譯器知道，讓編譯器產生object binary遵守這樣的規則，如

<ul>
<li>這個operand是一個暫存器</li>
<li>這個operand是一塊記憶體</li>
<li>這個operand是浮點常數</li>
<li>&hellip;</li>
</ul>
</li>
<li>不想讓編譯器幫你安排暫存器，而是在Inline Assembly指定暫存器的話，就要明確的列出來。讓編譯器知道這些暫存器有被改過資料，進而針對這些暫存器做適當的處理。</li>
</ul>


<p><a name="ia-env"></a></p>

<h2>測試環境</h2>

<p>我使用ARMv7為主的Banana Pi開發版加上Lubuntu 14.04作為測試環境。</p>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty

$ dmesg
...
[    0.000000] Linux version 3.4.90 (bananapi@lemaker) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #2 SMP PREEMPT Tue Aug 5 14:11:40 CST 2014
[    0.000000] CPU: ARMv7 Processor [410fc074] revision 4 (ARMv7), cr=10c5387d
...

$ gcc -v
...
Target: arm-linux-gnueabihf
...
gcc version 4.8.4 (Ubuntu/Linaro 4.8.4-2ubuntu1~14.04) 
</code></pre>

<p><a name="ia-syntax"></a></p>

<h2>語法</h2>

<p>inline assembler關鍵字是<code>asm</code>，不過<code>__asm__</code>也可以使用(<a href="#ia_ps0">註</a>)。</p>

<p>根據目前(Dec/2015)的<a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">gcc手冊</a>，inline assembler有分為<code>basic</code>和<code>extended</code>兩種。雖然我使用的平台是gcc 4.8.4，而且gcc 4.8.5<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/index.html#Top">手冊</a>(官方網站上沒有4.8.4手冊)並沒有提到這個部份。但是目前<strong>語法上</strong>測試的確沒有問題，但是有些說明上面卻很難驗證是否可以套用到4.8.5上(例如最佳化的說明、需要注意常犯的錯誤)，請自行斟酌。</p>

<p>以下是整理自最新的手冊說明，請自行斟酌您使用的gcc版本是否有符合。</p>

<h3>Basic inline assembler</h3>

<pre><code class="c">     [ volatile ] asm("Assembler Template");
</code></pre>

<p>以下是整理自最新(Dec/2015)的手冊說明節錄，請自行斟酌您使用的gcc版本是否有符合。</p>

<ul>
<li>basic inline assembler 預設就是volatile</li>
<li>基本上編譯器只是把引號內的東西抄錄，所以只要組譯器支援的語法，就可以寫入Assembler Template內</li>
<li>和extended inline assembler的差異

<ul>
<li>extended inline assembler 只允許在函數內使用</li>
<li>有<code>naked</code>屬性的函數必須使用basic inline assembler(見<a href="#ia_ps1">註解</a>)</li>
<li>basic inline assembler就是把template內的字串作為組合語言組譯。而<code>%</code>字元在extended inline assembler有特別意義，然而有些組合語言如x86中<code>%</code>是暫存器語法的一部份。以至於<code>%</code>字元要在extended inline assembler中改為<code>%%</code>才是真正的意思，舉個例子<code>%eax</code>-><code>%%eax</code></li>
</ul>
</li>
<li>有要使用C 語言的資料，使用extended inline assembler比較妥當</li>
<li>GCC 最佳化時是有可能把你的inline assembler幹掉或是和你想的不一樣，請注意</li>
<li>你不可以從一個<code>asm(..)</code>裏面跳到另外一個<code>asm(..)</code>的label</li>
</ul>


<p>最簡單的<del>廢話</del>範例如下
<code>c
    asm("nop"); /* 啥事都不要做 */
</code></p>

<p>在沒有使用C 語言的變數下，就和一般的組合語言沒有差太多。
更複雜一點的例子可以看<a href="https://github.com/embedded2014/rtenv/blob/master/kernel.c#L10">rtenv</a>裏面的使用方式：</p>

<pre><code class="c">size_t strlen(const char *s) __attribute__ ((naked));
size_t strlen(const char *s)
{
    asm(
        "    sub  r3, r0, #1            \n"
        "strlen_loop:               \n"
        "    ldrb r2, [r3, #1]!        \n"
        "    cmp  r2, #0                \n"
        "   bne  strlen_loop        \n"
        "    sub  r0, r3, r0            \n"
        "    bx   lr                    \n"
        :::
    );
}
</code></pre>

<p>要注意<code>__attribute__ ((naked));</code>是有意義的。這是為何這段範例沒有直接指名用到C 語言函式變數名稱的關鍵點。有興趣請看<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html#ARM-Function-Attributes">這邊</a>，請直接找字串<code>naked</code>。</p>

<h3>Extended inline assembler</h3>

<pre><code class="c">     asm [volatile] ( AssemblerTemplate
                        : OutputOperands   // optional
                      [ : InputOperands    // optional
                      [ : Clobbers ]       // optional
                      ])
</code></pre>

<p>Assembler Template基本上就是你要寫的組語加上 Inline Assembler 專用的符號。要注意的是，在編譯的過程中，你寫的inline assembler可能由於最佳化考慮不會被組譯。如果你確認你inline assembler一定要被組譯，請加上<code>volatile</code> keyword。</p>

<p>Assembler 專用的符號節錄如下：</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width=15%">%%</td>
        <td>單一%字元</td>
    </tr>
    <tr>
        <td>%{</td>
        <td>單一{字元</td>
    </tr>
    <tr>
        <td>%}</td>
        <td>單一}字元</td>
    </tr>
    <tr>
        <td>|{</td>
        <td>單一|字元</td>
    </tr>
    <tr>
        <td>%=</td>
        <td>只知道並驗證過會產生唯一的數字。用途部份看不懂，英文真是奧妙的東西啊。</td>
    </tr>
</table>


<p></p>

<p>AssemblerTemplate</p>

<p>由於<a href="#ia-preface">前言</a>提到的三項個人猜測，造成inline assembler要使用C 語言變數時語法會出現很多令人眼花撩亂的符號。</p>

<p>由於編譯器提供協助分配暫存器和記憶體，也就是說需要有對應的語法指定目前指令的operand是什麼。GCC 有兩種方式指定，分別是</p>

<ul>
<li>編號指定，從零開始編號</li>
<li>Symbolic name指定: GCC 3.1以後支援<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">出處</a></li>
</ul>


<p>分別給個範例讓各位感受一下</p>

<h4>編號指定，從零開始編號</h4>

<p>這邊<code>%0</code>, <code>%1</code>就是編號。後面operand可以看到就是指定變數、以及變數的限制。這邊簡單解釋一下<code>=</code>表示這是一個輸出、而<code>r</code>表示變數要放在暫存器中、<code>m</code>表示變數是放在記憶體中。有興趣比對編譯出來的binary反組譯時的組合語言請看<a href="#ia_ps2">這邊</a>。不過編號和指令中的operand似乎很隨意，我沒有看到特殊規範。只能交叉比對assembler template和input/output operands才能看出端倪。我猜更複雜的情況你還要比對反組譯出來的結果。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int main(void)
{
    int var1 = 12;
    int var2 = 10;

    asm("mov %0, %1 \n  \
         add %1, %0, $1" : "=r"(var1), "=r"(var2) : "r"(var2), "r"(var1):);
    printf("var1 = %d, var2 = %d\n", var1, var2);

    asm("ldr r5, %0 \n":           : "m"(var1): "r5");
    asm("str r4, %0"   : "=m"(var2):          : "r4");
    return 0;
}
</code></pre>

<h4>Symbolic name指定</h4>

<p>編號的缺點就是可讀性比較差，所以gcc 3.1出現使用symbolic name的方式。至於那一個比較好，看你自己習慣。</p>

<p>直接把上面的範例更改一下。<a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">GCC 4.8.5手冊</a>上面說symbolic name隨便取，甚至和變數同名稱都可以，<strong>只要單一asm(&hellip;)內的 symbolic name不要重複就好</strong>。有興趣比對編譯出來的binary反組譯時的組合語言請看<a href="#ia_ps3">這邊</a>。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int main(void)
{
    int var1 = 12;
    int var2 = 10;

    asm("mov %[my_var1], %[my_var2] \n  \
         add %[my_var3], %[my_var4], $1" : 
            [my_var1] "=r" (var1), [my_var3] "=r" (var2) :
            [my_var2] "r"  (var2), [my_var4] "r"  (var1) :);
    printf("var1 = %d, var2 = %d\n", var1, var2);

    asm("ldr r5, %[my_var1] \n":: [my_var1] "m"(var1): "r5");
    asm("str r4, %[my_var1]": [my_var1] "=m" (var2):: "r4");
    return 0;
}
</code></pre>

<p>接下來來看每個欄位吧。</p>

<p><a name="ia-output"></a></p>

<h4>Output operands</h4>

<pre><code class="c">    [ [asmSymbolicName] ] constraint (cvariablename)
</code></pre>

<p><code>[asmSymbolicName]</code> 是GCC 3.1以後支援語法，如前所述，不用Symbolic Name就用編號方式對應assembler template operand。</p>

<p>指定結果要存在C 語言中的那個變數。要注意的除了要設定對的資訊（constraints，<a href="#ia-constr">下面</a>會節錄) 以外，operand的prefix一定要是<code>=</code>或<code>+</code>這兩個constraint。</p>

<p>隨便舉幾個範例</p>

<ul>
<li><code>=r(var1)</code>：變數請寫入並放在暫存器中</li>
<li><code>=m(var1)</code>：變數請寫入並存到記憶體中</li>
</ul>


<p><a name="ia-input"></a></p>

<h4>Input operands</h4>

<pre><code class="c">    [ [asmSymbolicName] ] constraint (cvariablename)
</code></pre>

<p><code>[asmSymbolicName]</code> 是GCC 3.1以後支援語法，如前所述，不用Symbolic Name就用編號方式對應assembler template operand。</p>

<p>指定要從在C 語言中的那個變數取出資料。主要是要設定對的資訊（constraints，<a href="#ia-constr">下面</a>會節錄) 。</p>

<ul>
<li><code>r(var1)</code>：變數請放在暫存器中</li>
<li><code>m(var1)</code>：變數是在記憶體中</li>
</ul>


<p><a name="ia-clo-reg"></a></p>

<h4>Clobbered registers list</h4>

<p>先講結論，在<code>asm("語法")</code>中明確地指定暫存器名稱的話，要在這邊列出。</p>

<p>現在我會習慣查單字。<code>Clobbered</code>查英文單字會發現就是把東西用力地砸毀。所以翻譯成中文就是「砸爛的暫存器列表」。什麼是爛掉的暫存器？就是本節前面的結論囉。</p>

<p>另外從Dec/2015的gcc 手冊還有找到下面<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers">語法</a>，一樣請注意版本問題</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">&#8220;cc&#8221;</td>
        <td>和狀態有關的flag暫存器會被修改</td>
    </tr>
    <tr>
        <td>&#8220;memory&#8221;</td>
        <td>這段組合語言會讀寫列出operand以外的記憶體內容，因此編譯器會視情況備份暫存器或讀寫記憶體</td>
    </tr>
</table>


<p><a name="ia-constr"></a></p>

<h3>Constraints</h3>

<pre><code class="c">&lt;Constraints&gt;       ::= &lt;Constraint Modifier&gt; &lt;Other Constraints&gt; | &lt;Other Constraints&gt;
&lt;Other Constraints&gt; ::= &lt;Simple Constraints&gt; | &lt;Machine Constraints&gt;

; /* 以上BNF是我整理的，terminal symbol請自行看手冊 */
</code></pre>

<p>節錄整理我<del>看得懂</del>感興趣的部份。</p>

<h5>Simple Constraints</h5>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">空白字元</td>
        <td>會被忽略，排版用</td>
    </tr>
    <tr>
        <td>m</td>
        <td>operand 存放在記憶體中</td>
    </tr>
    <tr>
        <td>r</td>
        <td>operand 將被放在暫存器中</td>
    </tr>
    <tr>
        <td>i</td>
        <td>operand 是一個整數常數，該常數包含下面的情形(symbolic name)：`#define MAX_LINE (32)`</td>
    </tr>
    <tr>
        <td>n</td>
        <td>operand 是一個整數常數，只允許填入數字</td>
    </tr>
    <tr>
        <td>E</td>
        <td>operand 是一個浮點數常數，不清楚和`F`的差異</td>
    </tr>
    <tr>
        <td>F</td>
        <td>operand 是一個浮點數常數，不清楚和`E`的差異</td>
    </tr>
    <tr>
        <td>g</td>
        <td>operand 存在暫存器(r)或是記憶體內(m)，或是這是一個整數常數</td>
    </tr>    
    <tr>
        <td>X</td>
        <td>不用檢查operand</td>
    </tr>
</table>


<p>　　</p>

<p>你可以使用組合技如<code>"rim"</code>，如果這樣寫的話，意思是要編譯器幫你挑一個最適合的方式處理對應於assembler template內的operand。
　　</p>

<h5>Constraint Modifier</h5>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明</th>
    </tr>
    <tr>
        <td width="15%">=</td>
        <td>表示這是一個write only的operand，必須為contraint開始字元。</td>
    </tr>
    <tr>
        <td>+</td>
        <td>表示這個 operand 在指令中是同時被讀寫的，必須為contraint開始字元。</td>
    </tr>
    <tr>
        <td>&</td>
        <td>該operand 為earlyclobber。earlyclobber就是在instruction讀取該operand前，該operand會被寫入。雖然如此，到底是多久前？是和data hazard有關嘛？還是跟資料一致性有關？或者是和編譯器 最佳化造成非預期結果有關？真是一團謎<font color="red">完全搞不懂做啥用，也不清楚使用時機。</font><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/uaccess.h#L364">這邊有範例</a>，一樣搞不懂為什麼要有+, &的modifier</td>
    </tr>
    <tr>
        <td>%</td>
        <td>該operand 可以讓編譯器 決定這個operand是否和後面的operand交換(commutative)，<font color="red">完全搞不懂做啥用</font></td>
    </tr>
</table>


<p>　　</p>

<h5>ARM 專用的Constraint</h5>

<p>我參考的是gcc 4.8.5手冊(因為和測試環境的gcc版本最接近)，可能有版本的問題，這些我都沒有做實驗測試，請自行斟酌。</p>

<table  style="width:100%">
    <tr>
        <th>符號</th>
        <th>說明(一般模式)</th>
    </tr>
    <tr>
        <td width="20%">w</td>
        <td width="80%">VFP 浮點運算</td>
    </tr>
    <tr>
        <td>G</td>
        <td>浮點運算的0.0</td>
    </tr>
    <tr>
        <td>I</td>
        <td>8 bit正整數</td>
    </tr>
    <tr>
        <td>K</td>
        <td>I contraint 的invert (一的補數)，Wen: 不知道為什麼要扯到I constraint？</td>
    </tr>
    <tr>
        <td>L</td>
        <td>I contraint 的負數 (二的補數)，Wen: 不知道為什麼要扯到I constraint？</td>
    </tr>
    <tr>
        <td>M</td>
        <td>0 ~ 32的正整數</td>
    </tr>
    <tr>
        <td>Q</td>
        <td>要參考的記憶體位址存放在一個暫存器內</td>
    </tr>
    <tr>
        <td>R</td>
        <td>operand是一個const pool內的東西，不要問我const pool是啥，估狗到都和Java有關</td>
    </tr>
    <tr>
        <td>S</td>
        <td>operand 目前檔案中.text內的一個symbol</td>
    </tr>
    <tr>
        <td>Uv</td>
        <td>VFP load/store 指令可存取的記憶體</td>
    </tr>
    <tr>
        <td>Uy</td>
        <td>iWMMXt load/store 指令可存取的記憶體</td>
    </tr>
    <tr>
        <td>Uq</td>
        <td>ARMv4 ldrsb 指令可存取的記憶體</td>
    </tr>
</table>


<p></p>

<p>完整列表在這邊，要注意的是2015年12月的手冊又多了一些新的contstraint。請自行參考。</p>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Machine-Constraints.html#Machine-Constraints">gcc 4.8.5: Constraints for Particular Machines</a>

<ul>
<li>請自行參考你的硬體平台</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">Dec/2015手冊: 6.44.4.4 Constraints for Particular Machines</a></li>
</ul>


<p><a name="ia-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li>中文

<ul>
<li><a href="http://www.study-area.org/cyril/opentools/opentools/x969.html">(BIG5)用Open Source工具開發軟體: 新軟體開發關念: Chapter 4. GNU Compiler Collection</a>

<ul>
<li>題外話，寫這位文件的作者個人非常佩服，但是網路上似乎關於這位作者只有這份文件。真是神祕的人物</li>
</ul>
</li>
<li><a href="http://nano-chicken.blogspot.tw/2010/12/inline-assembly.html">Nano雞排: Inline Assembly</a></li>
</ul>
</li>
<li>英文

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">gcc: How to Use Inline Assembly Language in C Code</a>

<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/index.html#Top">手冊</a>上寫是給<code>gcc 6.0</code>，我目前從GGG release網站上看到<a href="https://gcc.gnu.org/releases.html">最新版本</a>是5.3，怪。</li>
<li>為什麼列出這個，因為我原本找的gcc-4.8.5 對於assembler template說明沒有特別列出gcc 支援的inline assembler符號。另外這份的文件結構的確比4.8.5清楚。</li>
</ul>
</li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Extended-Asm.html#Extended-Asm">gcc-4.8.5: Assembler Instructions with C Expression Operands</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Constraints.html#Constraints">gcc-4.8.5: Constraints for asm Operands</a></li>
<li><a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM GCC Inline Assembler Cookbook</a>

<ul>
<li>相當推荐，不論是給的說明和範例，更厲害的是關於contraint部份寫的比手冊清楚，一樣我沒測過就是了。</li>
</ul>
</li>
<li><a href="http://ericw.ca/notes/a-tiny-guide-to-gcc-inline-assembly.html">A Tiny Guide to GCC Inline Assembly</a></li>
<li><a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a></li>
<li><a href="http://wiki.osdev.org/Inline_Assembly">OSDev: Inline Assembly</a></li>
<li><a href="http://asm.sourceforge.net/articles/rmiyagi-inline-asm.txt">Introduction to GCC inline assembler</a>

<ul>
<li>似乎有點古老。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>附錄</h2>

<p><a name="ia_ps0"></a></p>

<ul>
<li>C 語言標準有提到編譯器可以使用<code>asm</code> keyword，而且沒有定義語法。有興趣可以找<code>C11</code>、<code>C99</code>、<code>C89</code>的標準，直接搜尋<code>asm</code>就可以看到了。</li>
</ul>


<hr />

<p><a name="ia_ps1"></a></p>

<ul>
<li><code>naked</code>使用basic inline assembler和extended inline assembler比較</li>
</ul>


<p>下面兩個函數，<code>strcmp1</code>沒有任何extended inline assembler而<code>strcmp2</code>硬塞了一個下去：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">strcmp1</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">attribute</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="p">((</span><span class="kr">naked</span><span class="p">));</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">strcmp1</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">asm</span><span class="p">(</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="nl">strcmp_lop1</span><span class="p">:</span>                <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">ldrb</span>    <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r0</span><span class="p">],</span><span class="err">#</span><span class="mi">1</span>     <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">ldrb</span>    <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">],</span><span class="err">#</span><span class="mi">1</span>     <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">cmp</span>     <span class="n">r2</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>          <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">it</span>      <span class="n">hi</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">cmphi</span>   <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>          <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">beq</span>     <span class="n">strcmp_lop1</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>    <span class="n">sub</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">bx</span>      <span class="n">lr</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">:::</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">strcmp2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">attribute</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="p">((</span><span class="kr">naked</span><span class="p">));</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">strcmp2</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">asm</span><span class="p">(</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="nl">strcmp_lop2</span><span class="p">:</span>                <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">ldrb</span>    <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r0</span><span class="p">],</span><span class="err">#</span><span class="mi">1</span>     <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">ldrb</span>    <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">],</span><span class="err">#</span><span class="mi">1</span>     <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">cmp</span>     <span class="n">r2</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>          <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">it</span>      <span class="n">hi</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">cmphi</span>   <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>          <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">mov</span>     <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">1</span> <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">beq</span>     <span class="n">strcmp_lop2</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>    <span class="n">sub</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">bx</span>      <span class="n">lr</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">:&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">=</span><span class="n">r</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;(</span><span class="n">i</span><span class="p">)</span><span class="o">::</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>我們可以比較一下下面兩個函數最後編譯出來的指令，<code>strcmp2</code>顯然和我們預期的差很多。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mf">000083f</span><span class="mi">4</span> <span class="o">&lt;</span><span class="n">strcmp1</span><span class="o">&gt;:&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">strcmp1</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">attribute</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="p">((</span><span class="kr">naked</span><span class="p">));</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">strcmp1</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">asm</span><span class="p">(</span>
</span><span class='line'>    <span class="mf">83f</span><span class="mi">4</span><span class="o">:</span>   <span class="n">f810</span> <span class="mi">2</span><span class="n">b01</span>   <span class="n">ldrb</span><span class="p">.</span><span class="n">w</span>  <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r0</span><span class="p">],</span> <span class="err">#</span><span class="mi">1</span>
</span><span class='line'>    <span class="mf">83f</span><span class="mi">8</span><span class="o">:</span>   <span class="n">f811</span> <span class="mi">3</span><span class="n">b01</span>   <span class="n">ldrb</span><span class="p">.</span><span class="n">w</span>  <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="err">#</span><span class="mi">1</span>
</span><span class='line'>    <span class="mf">83f</span><span class="nl">c</span><span class="p">:</span>   <span class="mi">2</span><span class="n">a01</span>        <span class="n">cmp</span> <span class="n">r2</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>
</span><span class='line'>    <span class="mf">83f</span><span class="nl">e</span><span class="p">:</span>   <span class="n">bf88</span>        <span class="n">it</span>  <span class="n">hi</span>
</span><span class='line'>    <span class="mi">8400</span><span class="o">:</span>   <span class="mi">429</span><span class="n">a</span>        <span class="n">cmphi</span>   <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>
</span><span class='line'>    <span class="mi">8402</span><span class="o">:</span>   <span class="n">d0f7</span>        <span class="n">beq</span><span class="p">.</span><span class="n">n</span>   <span class="mf">83f</span><span class="mi">4</span> <span class="o">&lt;</span><span class="n">strcmp1</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="mi">8404</span><span class="o">:</span>   <span class="n">eba2</span> <span class="mo">0003</span>   <span class="n">sub</span><span class="p">.</span><span class="n">w</span>   <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>
</span><span class='line'>    <span class="mi">8408</span><span class="o">:</span>   <span class="mi">4770</span>        <span class="n">bx</span>  <span class="n">lr</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">beq</span>     <span class="n">strcmp_lop1</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>    <span class="n">sub</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">bx</span>      <span class="n">lr</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">:::</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>    <span class="mi">840</span><span class="nl">a</span><span class="p">:</span>   <span class="mi">4618</span>        <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r3</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="mo">0000</span><span class="mi">840</span><span class="n">c</span> <span class="o">&lt;</span><span class="n">strcmp2</span><span class="o">&gt;:</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">beq</span>     <span class="n">strcmp_lop2</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>    <span class="n">sub</span>     <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>      <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>   <span class="n">bx</span>      <span class="n">lr</span>              <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>        <span class="o">:&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">=</span><span class="n">r</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;(</span><span class="n">i</span><span class="p">)</span><span class="o">::</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;---</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;ia_ps2&quot;</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">/</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span> <span class="err">範例一的反組譯節錄</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">S</span> <span class="n">asm</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span><span class='line'><span class="mf">000083f</span><span class="mi">4</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span><span class='line'>    <span class="mf">83f</span><span class="nl">a</span><span class="p">:</span>   <span class="mi">230</span><span class="n">c</span>        <span class="n">movs</span>    <span class="n">r3</span><span class="p">,</span> <span class="err">#</span><span class="mi">12</span>
</span><span class='line'>    <span class="mf">83f</span><span class="nl">c</span><span class="p">:</span>   <span class="mi">603</span><span class="n">b</span>        <span class="n">str</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">var2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="mf">83f</span><span class="nl">e</span><span class="p">:</span>   <span class="mi">230</span><span class="n">a</span>        <span class="n">movs</span>    <span class="n">r3</span><span class="p">,</span> <span class="err">#</span><span class="mi">10</span>
</span><span class='line'><span class="mi">8400</span><span class="o">:</span>   <span class="mi">607</span><span class="n">b</span>        <span class="n">str</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">asm</span><span class="p">(</span><span class="s">&quot;mov %0, %1 </span><span class="se">\n</span><span class="s">  \</span>
</span><span class='line'><span class="s">     add %1, %0, $1&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">var1</span><span class="p">),</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">var2</span><span class="p">),</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span><span class="o">:</span><span class="p">);</span>
</span><span class='line'><span class="mi">8402</span><span class="o">:</span>   <span class="mi">687</span><span class="n">b</span>        <span class="n">ldr</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'><span class="mi">8404</span><span class="o">:</span>   <span class="mi">683</span><span class="n">a</span>        <span class="n">ldr</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="mi">8406</span><span class="o">:</span>   <span class="mi">461</span><span class="n">a</span>        <span class="n">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span>
</span><span class='line'><span class="mi">8408</span><span class="o">:</span>   <span class="n">f102</span> <span class="mo">0301</span>   <span class="n">add</span><span class="p">.</span><span class="n">w</span>   <span class="n">r3</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>
</span><span class='line'><span class="mi">840</span><span class="nl">c</span><span class="p">:</span>   <span class="mi">603</span><span class="n">a</span>        <span class="n">str</span> <span class="n">r2</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'><span class="mi">840</span><span class="nl">e</span><span class="p">:</span>   <span class="mi">607</span><span class="n">b</span>        <span class="n">str</span> <span class="n">r3</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span><span class='line'>    <span class="n">asm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">ldr</span> <span class="n">r5</span><span class="p">,</span> <span class="o">%</span><span class="mi">0</span> <span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">:</span>           <span class="o">:</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">m</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;(</span><span class="n">var1</span><span class="p">)</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">r5</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="mi">8424</span><span class="o">:</span>   <span class="mi">683</span><span class="n">d</span>        <span class="n">ldr</span> <span class="n">r5</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">asm</span><span class="p">(</span><span class="s">&quot;str r4, %0&quot;</span>   <span class="o">:</span> <span class="s">&quot;=m&quot;</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span><span class="o">:</span>          <span class="o">:</span> <span class="s">&quot;r4&quot;</span><span class="p">);</span>
</span><span class='line'><span class="mi">8426</span><span class="o">:</span>   <span class="mi">607</span><span class="n">c</span>        <span class="n">str</span> <span class="n">r4</span><span class="p">,</span> <span class="p">[</span><span class="n">r7</span><span class="p">,</span> <span class="err">#</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<hr />

<p><a name="ia_ps3"></a></p>

<ul>
<li>範例二的反組譯節錄</li>
</ul>


<pre><code class="c">$ objdump -d -S asm
...
000083f4 &lt;main&gt;:
#include &lt;stdio.h&gt;

int main(void)
{
...
    int var1 = 12;
    83fa:   230c        movs    r3, #12
    83fc:   603b        str r3, [r7, #0]

    int var2 = 10;
    83fe:   230a        movs    r3, #10
    8400:   607b        str r3, [r7, #4]

    asm("mov %[my_var1], %[my_var2] \n  \
         add %[my_var3], %[my_var4], $1" : 
            [my_var1] "=r" (var1), [my_var3] "=r" (var2) :
            [my_var2] "r"  (var2), [my_var4] "r"  (var1) :);
    8402:   687b        ldr r3, [r7, #4]
    8404:   683a        ldr r2, [r7, #0]
    8406:   461a        mov r2, r3
    8408:   f102 0301   add.w   r3, r2, #1
    840c:   603a        str r2, [r7, #0]
    840e:   607b        str r3, [r7, #4]
...
    asm("ldr r5, %[my_var1] \n":: [my_var1] "m"(var1): "r5");
    8424:   683d        ldr r5, [r7, #0]

    asm("str r4, %[my_var1]": [my_var1] "=m" (var2):: "r4");
    8426:   607c        str r4, [r7, #4]
...
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Linux ARM 組合語言]]></title>
    <link href="http://wen00072.github.io/blog/2015/04/22/hello-assembly/"/>
    <updated>2015-04-22T21:34:16+08:00</updated>
    <id>http://wen00072.github.io/blog/2015/04/22/hello-assembly</id>
    <content type="html"><![CDATA[<h2>目錄</h2>

<ul>
<li><a href="#hello-asm-syntax">前言</a></li>
<li><a href="#hello-asm-env">測試環境</a></li>
<li><a href="#hello-asm-ex1">範例：版本一</a></li>
<li><a href="#hello-asm-ex2">範例：版本二</a></li>
<li><a href="#hello-asm-ex3">範例：版本三</a></li>
<li><a href="#hello-asm-ex4">範例：版本四</a></li>
<li><a href="#hello-asm-conl">總結</a></li>
<li><a href="#hello-asm-ext">延伸閱讀及致謝</a></li>
<li><a href="#hello-asm-ref">參考資料</a></li>
</ul>


<p><a name="hello-asm-syntax"></a></p>

<h2>前言</h2>

<p>之前的文章有不少在討論執行檔該長怎麼樣。簡單來說，一個執行檔會有</p>

<ul>
<li>Sections：程式行為和資料會分開放在不同的sections</li>
<li>進入點，也就是system call開始執行你的程式的地方</li>
</ul>


<p>以這樣的觀點，來看組合語言，會比較有感覺。</p>

<p>這次主要想要試看看如何使用組合語言印出Hello world。學過作業系統的朋友應該知道OS真正提供給使用者的介面叫作system call。有興趣的朋友可以使用<code>strace</code>研究執行檔呼叫了那些system call。這次的Hello world我有兩個線索</p>

<ul>
<li>在command line執行的process會有3個馬上可以使用的file descriptor（不知道那啥的請自行估狗）分別是

<ul>
<li><code>0</code>: standard in</li>
<li><code>1</code>: standard out</li>
<li><code>2</code>: standard error</li>
</ul>
</li>
<li>有一個system call叫作<code>write</code>，你可以透過他把任何資料寫到指令的file descriptor</li>
</ul>


<p>綜合以上，我們要幹的事就是透過組合語言做出</p>

<pre><code class="c">write(1, "Hello world\n", 12);
</code></pre>

<p>這又表示組合語言中我們要做</p>

<ul>
<li>呼叫system call</li>
<li>帶參數給system call，這部份需要有

<ul>
<li>ABI的背景知識</li>
<li>定址方式，更精確的說，如何宣告<code>"Hello world\n"</code>，讓runtime時放在在process address space中，並將它的位址傳給system call</li>
</ul>
</li>
</ul>


<p><a name="hello-asm-env"></a></p>

<h2>測試環境</h2>

<ul>
<li><p>Host
<code>text
$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.2 LTS
Release:    14.04
Codename:   trusty
</code></p></li>
<li><p>Guest OS on Qemu</p>

<ul>
<li>這邊很奇怪我的kernel用更新過的版本Qemu完全無法開機。目前裝死中。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>$ lsb_release -a
</span><span class='line'>No LSB modules are available.
</span><span class='line'>Distributor ID: Debian
</span><span class='line'>Description:    Debian GNU/Linux 8.0 (jessie)
</span><span class='line'>Release:    8.0
</span><span class='line'>Codename:   jessie&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;$ cat /proc/cpuinfo
</span><span class='line'>Processor   : ARM926EJ-S rev 5 (v5l)
</span><span class='line'>BogoMIPS    : 643.48
</span><span class='line'>Features    : swp half thumb fastmult vfp edsp java
</span><span class='line'>CPU implementer : 0x41
</span><span class='line'>CPU architecture: 5TEJ
</span><span class='line'>CPU variant : 0x0
</span><span class='line'>CPU part    : 0x926
</span><span class='line'>CPU revision    : 5&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Hardware    : ARM-Versatile AB
</span><span class='line'>Revision    : 0000
</span><span class='line'>Serial      : 0000000000000000
</span></code></pre></td></tr></table></div></figure></p>

<p><a name="hello-asm-ex1"></a></p>

<h2>範例：版本一</h2>

<p>我本來想說慢慢來，先來個完全沒意義的r0 = 0; r1 = 1; r2 = r0 + r1。程式如下：
<code>asm hello.s
.text
.global _start
_start:
    mov %r0, $0
    mov %r1, $1
    add %r2, %r0, %r1
.end
</code>
幾點說明：</p>

<ul>
<li><code>$</code>或是<code>#</code>代表一個數字(<a href="https://sourceware.org/binutils/docs/as/ARM_002dChars.html#ARM_002dChars">出處</a>)</li>
<li><code>%r1</code>代表ARM的<code>r1</code>暫存器，但是為何用<code>%</code>目前沒找到手冊上有說明。</li>
<li><code>.text</code>前面的文章有看應該覺得很眼熟，就是告訴編譯器以下是程式行為。</li>
<li><code>global</code>是讓symbol可以外露，白話來說就是<code>nm</code>等binutil可以看的到這個symbol。</li>
<li><code>_start</code>是一個程式執行的起始點，有看過<a href="http://wen00072.github.io/blog/2015/02/14/main-linux-whos-going-to-call-in-c-language/">之前文章</a>就會覺得很眼熟。</li>
<li><p><a href="https://sourceware.org/binutils/docs/as/End.html#End">.end表示程式結束點</a>，不過目前用起來有沒有加好像沒有差別。</p></li>
<li><p>Makefile</p></li>
</ul>


<pre><code class="makefile Makefile">TARGET=hello
AS_FILE=$(addsuffix .s, $(TARGET))

$(TARGET): $(AS_FILE)
    $(AS) $^ -o $@

clean:
    rm -rf $(TARGET)
</code></pre>

<p>想法很簡單，就是直接編譯應該可以跑，雖然完全不會有畫面。<font color="red">錯！</font>跑出來會這樣</p>

<pre><code class="text">$ make
as hello.s -o hello

$ ls -gG
total 12
-rw-r--r-- 1 588 Apr 20 18:04 hello
-rw-r--r-- 1  83 Apr 20 17:58 hello.s
-rw-r--r-- 1 113 Apr 20 17:58 Makefile
</code></pre>

<p>這代表什麼，hello編譯完後的binary本身沒有執行權限。改改權限看可不可以跑？</p>

<pre><code class="text">$ chmod +x hello
$ ./hello 
bash: ./hello: cannot execute binary file: Exec format error
</code></pre>

<p>怎麼回事？分析一下</p>

<pre><code class="text">$ readelf hello -h
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          268 (bytes into file)
  Flags:                             0x5000000, Version5 EABI
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         8
  Section header string table index: 5
</code></pre>

<p>看不出來對不對？我是這樣啦，所以先比對<code>/bin/ls</code>的輸出吧</p>

<pre><code class="text">$ readelf /bin/ls -h
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x14354
  Start of program headers:          52 (bytes into file)
  Start of section headers:          99372 (bytes into file)
  Flags:                             0x5000202, has entry point, Version5 EABI, soft-float ABI
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         27
  Section header string table index: 26
</code></pre>

<p>仔細看一下<code>Type:</code>，<code>/bin/ls</code>是<code>EXEC</code>而<code>hello</code>是<code>REL</code>，<code>man elf</code>可以看到<code>REL</code>是relocate file，那是啥呢？根據<a href="http://www.sco.com/developers/gabi/latest/contents.html">System V Application Binary Interface - DRAFT - 10 June 2013第四章的簡介</a>，簡單來說就是object檔案，也就是說link時吃的檔案。所以我們加入Link吧。</p>

<p><a name="hello-asm-ex2"></a></p>

<h2>範例：版本二</h2>

<p>單純加入linker看看會怎樣？
<figure class='code'><figcaption><span>Makefile</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='makefile'><span class='line'><span class="nv">TARGET</span><span class="o">=</span>hello
</span><span class='line'><span class="nv">AS_FILE</span><span class="o">=</span><span class="k">$(</span>addsuffix .s, <span class="k">$(</span>TARGET<span class="k">))</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;p&gt;$(TARGET)</span><span class="o">:</span> <span class="k">$(</span><span class="nv">AS_FILE</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>AS<span class="k">)</span> <span class="nv">$^</span> -o <span class="nv">$@</span>.o
</span><span class='line'>    <span class="k">$(</span>LD<span class="k">)</span> <span class="nv">$@</span>.o -o <span class="nv">$@</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;p&gt;clean</span><span class="o">:</span>
</span><span class='line'>    rm -rf <span class="k">$(</span>TARGET<span class="k">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>kerker，一樣GG。</p>

<pre><code class="text">$ make
as hello.s -o hello.o
ld hello.o -o hello
$ ./hello 
Illegal instruction
</code></pre>

<p>估狗到的組合語言的<a href="http://peterdn.com/post/e28098Hello-World!e28099-in-ARM-assembly.aspx">Hello world範例</a>最後會呼叫<code>exit</code> system call，照著呼叫<code>exit</code>就可以正常結束，這就是第三版。至於為何會出現<code>Illegal instruction</code>，根據<a href="http://scottt.tw/">Scott Tsai大大</a>的提示，當你的程式碼跑完後，接下來記憶體有啥CPU就跑啥，跑到不認識的opcode當然就GG了。</p>

<p><a name="hello-asm-ex3"></a></p>

<h2>範例：版本三</h2>

<pre><code class="asm hello.s">.text
.global _start
_start:
    mov     %r0, $0
    mov     %r7, $1
    svc     $0
.end
</code></pre>

<p>單純叫了<code>exit</code>而已，有幾點注意的
根據<a href="https://wiki.debian.org/ArmEabiPort#System_call_interface">Debian ARM system call interface</a>，可以知道</p>

<ul>
<li>r0 ~ r6是函數的帶入參數</li>
<li>r7 是system call number，而system call number是啥呢？就是你要的system call 對應的數字。</li>
</ul>


<p>所以要呼叫<code>exit(0)</code> system 表示</p>

<ul>
<li>傳一個參數，數值為<code>0</code></li>
<li>要設定<code>exit</code>對應的system call number為<code>1</code>。</li>
</ul>


<p>為何system call number是<code>1</code>呢？可以看看<a href="https://git.kernel.org/cgit/linux/kernel/git/rpi/linux-rpi.git/tree/arch/arm/include/asm/unistd.h">unistd.h</a>裏面system call number的定義，exit的system call number為<code>1</code>。</p>

<p>設定完傳給<code>exit</code>參數後呼叫了一個組合語言指令<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489g/Cihidabi.htmll"><code>svc</code></a>，這個指令主要是切換到Supervisor模式。Linux下面也許太過複雜，不太容易從user mode一路追到kernel然後又看懂這些system call的行為。沒關係成大資工作業有比較看得懂的範例可以參考。例如<a href="https://github.com/embedded2014/rtenv/blob/master/syscall.s#L6">包裝呼叫system call的函數</a>以及<a href="https://github.com/embedded2014/rtenv/blob/master/kernel.c#L1135">Kernel中對應的system call服務實作</a>。</p>

<p>根據<a href="https://git.kernel.org/cgit/linux/kernel/git/rpi/linux-rpi.git/tree/arch/arm/include/asm/unistd.h">unistd.h</a>定義的system call number，<code>write</code>的system call number 是<code>4</code>，所以我們可以開始寫最後的版本了。</p>

<p><a name="hello-asm-ex4"></a></p>

<h2>範例：版本四</h2>

<p>開始之前，先來看男人怎麼介紹write system call的</p>

<pre><code class="c    ">ssize_t write(int fd, const void *buf, size_t count);
</code></pre>

<p>這代表</p>

<ul>
<li>有三個參數要傳給system call</li>
<li>有回傳值可以吃</li>
<li>其中一個參數是位址，這個位址我們會放<code>"Hello World\n"</code>字串</li>
</ul>


<p>那麼我先來看看怎麼放字串到記憶體</p>

<pre><code>.data
hello_str:
    .ascii "Hello World\n"
</code></pre>

<p><code>.data</code>如果有看我以前的文章，就知道這是放有初始值全域變數的地方。</p>

<p>而<code>hello_str</code>呢?嗯，對<code>_start:</code>有印象嗎？</p>

<p>這叫作label，是GNU組語中symbol的一種，有興趣可以看<a href="https://sourceware.org/binutils/docs/as/Labels.html#Labels">這邊</a>。根據手冊，label還有一個功能，代表目前跑到的位址。所以<code>_start:</code>就是<code>.text</code> section的起始位址。而<code>hello_str</code>就是<code>.data</code> section的起始位址。從這兩個label可以看到label只是一個位址，可以指向函數或是資料，這和C語言的指標有異曲同工之妙。有興趣的朋友可以去找function pointer和C語言的callback函數。</p>

<p>而<a href="https://sourceware.org/binutils/docs/as/Ascii.html#Ascii"><code>.ascii</code></a>，單純就是宣告字串指令。</p>

<p>呼叫<code>write</code> system call來還有兩個問題要處理</p>

<ul>
<li>如何取得<code>hello_str</code>對應的位址放到暫存器<code>r1</code>上面？</li>
<li>要怎麼算出<code>hello_str</code>字串的長度?</li>
</ul>


<p>關於第一個問題，<a href="https://sourceware.org/binutils/docs/as/ARM-Opcodes.html#ARM-Opcodes">GNU ARM組合語言有中將數值或位址放到暫存器的虛擬指令</a></p>

<pre><code class="asm">ldr &lt;register&gt; , = &lt;expression&gt;
</code></pre>

<p><a href="https://sourceware.org/binutils/docs/as/Expressions.html#Expressions">expression</a>是一種表示<strong>位置</strong>或是<strong>數值</strong>的方式。</p>

<p>恰巧<a href="https://sourceware.org/binutils/docs/as/Arguments.html#Arguments">symbol也算是一個expression</a>，所以可以表示成：</p>

<pre><code class="asm">ldr %r1, =hello_str
</code></pre>

<p>第二個問題呢？要介紹<a href="https://sourceware.org/binutils/docs/as/Dot.html#Dot"><code>.</code></a>了。之前看過linker script的朋友應該對於locale counter還有印象。locale counter代表目前的位置。加上<a href="https://sourceware.org/binutils/docs/as/Prefix-Ops.html#Prefix-Ops"><code>expression</code>也支援運算</a>。利用<code>hello_str</code>是<code>.data</code>
開頭，我們可以這樣做:</p>

<pre><code>.data
hello_str:
    ascii "Hello World\n"
hello_len = . - hello_str
</code></pre>

<p>綜合上面的討論，版本四組合語言會是
<figure class='code'><figcaption><span>hello.s</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='asm'><span class='line'><span class="na">.data</span>
</span><span class='line'><span class="nl">hello_str:</span>
</span><span class='line'>    <span class="na">.ascii</span> <span class="err">&amp;</span><span class="no">ldquo</span><span class="err">;</span><span class="no">Hello</span> <span class="no">World</span><span class="err">\</span><span class="no">n</span><span class="err">&amp;</span><span class="no">rdquo</span><span class="err">;</span>
</span><span class='line'><span class="nf">hello_len</span> <span class="err">=</span> <span class="p">.</span> <span class="p">-</span> <span class="no">hello_str</span><span class="err">&lt;/</span><span class="no">p</span><span class="err">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;</span><span class="nf">p</span><span class="err">&gt;</span><span class="no">.text</span>
</span><span class='line'><span class="na">.global</span> <span class="err">&lt;</span><span class="no">em</span><span class="err">&gt;</span><span class="no">start</span>
</span><span class='line'><span class="err">&lt;/</span><span class="nf">em</span><span class="err">&gt;</span><span class="no">start</span><span class="p">:</span>
</span><span class='line'>    <span class="err">/&lt;</span><span class="nf">em</span><span class="err">&gt;</span> <span class="nv">%r0</span> <span class="err">=</span> <span class="no">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="no">hello_str</span><span class="p">,</span> <span class="no">hello_len</span><span class="p">)</span><span class="err">;</span> <span class="err">&lt;/</span><span class="no">em</span><span class="err">&gt;/</span>
</span><span class='line'>    <span class="nf">mov</span>     <span class="nv">%r0</span><span class="p">,</span> <span class="no">$1</span>
</span><span class='line'>    <span class="nf">ldr</span>     <span class="nv">%r1</span><span class="p">,</span> <span class="err">=</span><span class="no">hello_str</span>
</span><span class='line'>    <span class="nf">ldr</span>     <span class="nv">%r2</span><span class="p">,</span> <span class="err">=</span><span class="no">hello_len</span>
</span><span class='line'>    <span class="nf">mov</span>     <span class="nv">%r7</span><span class="p">,</span> <span class="no">$4</span>
</span><span class='line'>    <span class="nf">svc</span>     <span class="no">$0</span><span class="err">&lt;/</span><span class="no">p</span><span class="err">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;</span><span class="nf">pre</span><span class="err">&gt;&lt;</span><span class="no">code</span><span class="err">&gt;/</span><span class="p">*</span> <span class="no">exit</span><span class="p">(</span><span class="nv">%r0</span><span class="p">)</span> <span class="p">*</span><span class="err">/</span>
</span><span class='line'><span class="nf">mov</span>     <span class="nv">%r7</span><span class="p">,</span> <span class="no">$1</span>
</span><span class='line'><span class="nf">svc</span>     <span class="no">$0</span>
</span><span class='line'><span class="err">&lt;/</span><span class="nf">code</span><span class="err">&gt;&lt;/</span><span class="no">pre</span><span class="err">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;</span><span class="nf">p</span><span class="err">&gt;</span><span class="no">.end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>等等，不是說有回傳值？還是要看<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ihi0042e/index.html">Procedure Call Standard for the ARM Architecture
ABI r2.09手冊</a>，上面提到回傳資料會放到<code>r0</code>，剛好接下來的<code>exit</code> system call帶的第一個參數也要存放在r0，那麼我們可以直接觀察執行後回傳值如下：</p>

<pre><code class="text">$ make
as hello.s -o hello.o
ld hello.o -o hello

$ ./hello 
Hello World
$ echo $?
12
</code></pre>

<h3>補充</h3>

<pre><code>ldr &lt;register&gt; , = &lt;expression&gt;
</code></pre>

<p>這是個有趣的指令，這個指令事實上是個虛擬指令。怎麼說呢，因為這個指令的目標是<strong>把數值塞到指定的暫存器</strong>。這個數值是位址還是啥死人骨頭並不重要。重要的是，由於opcode的限制，把數值塞到指定的暫存器會有限制滴。例如<code>ARM Cortex M0</code>的<code>MOV</code>的數值只有8-bit，要塞32-bit的數值就需要配合其他的指令做連續技。因此
<code>
ldr &lt;register&gt; , = &lt;expression&gt;
</code>
這樣的指令就可以讓你寫起來比較輕鬆。</p>

<p>另外一個值得一提是，如果組譯器無法把<code>ldr &lt;register&gt; , = &lt;expression&gt;</code>虛擬指令轉換成<code>MOV</code>或<code>MVN</code>指令，把你的數值塞到暫存器的話。組譯器會把你的值放在一塊記憶體中，使用<strong>真的</strong>ldr把這塊記憶體的值載入到暫存器中。這個方法稱為literal pool，細節可以看<a href="http://infocenter.arm.com/help/index.jsp?topic=%2Fcom.arm.doc.dui0473c%2FBgbccbdi.html">這邊</a>。</p>

<p><a name="hello-asm-conl"></a></p>

<h2>總結</h2>

<p>本文從會GG的組合語言一路改到可以印出Hello World，並且在程式結束後回傳字串長度。在文章中簡單提到了GNU as的</p>

<ul>
<li>組合語言中section</li>
<li>組合語言的編譯方式</li>
<li>組合語言中的symbol和字串表示方式</li>
<li>組合語言中的expression</li>
<li>ABI實例</li>
</ul>


<p>希望對有需要的朋友有所幫助。</p>

<p><a name="hello-asm-ext"></a></p>

<h2>延伸閱讀及致謝</h2>

<p>感謝<a href="http://scottt.tw/">Scott Tsai大大</a>提供的資料以及指出文章中錯誤的地方。另外他也有提到其他有趣的部份，當作以後的作業。先列出如下</p>

<ul>
<li><a href="http://stackoverflow.com/questions/28831763/hello-world-program-in-nasm-x86-64-prints-hello-world-continuously/28837680#28837680">從組合語言直接呼叫header file內的system call</a></li>
<li><a href="http://www.arm.linux.org.uk/developer/memory.txt">Kernel Memory Layout on ARM Linux</a>

<ul>
<li>這邊主要討論的是<code>objdump -d</code>發現obj檔和執行檔差別只在進入點位址的差別，而進入點位址如何決定呢？這邊有規範，另外也可以看default linker script看看如何設定的。</li>
</ul>
</li>
<li><a href="https://gist.github.com/scottt/a57220efc15d15569a2e">Scott大大的範例程式</a>

<ul>
<li>可以看到，這個版本和我參考寫出來的版本差異有

<ul>
<li>把<code>"Hello world"</code>放在<code>.rodata</code> section中，這比<code>.data</code>更實際，因為這個字串的確沒有必要設成全域變數。</li>
<li>使用了preprocess方式。</li>
<li>提供了反組譯的結果</li>
<li>提供X86-64版本的組合語言比較</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>感謝<a href="http://vh21.github.io">Viler Hsiao大大</a>寫文回答我的問題。</p>

<ul>
<li><a href="http://vh21.github.io/assembly/2015/04/20/read-assembly-code.html">Viler Hsiao: 閱讀assembly code</a></li>
</ul>


<p><a name="hello-asm-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://peterdn.com/post/e28098Hello-World!e28099-in-ARM-assembly.aspx">『Hello World!』 in ARM assembly</a>

<ul>
<li>本篇程式碼大量參考這篇。</li>
</ul>
</li>
<li><a href="https://sourceware.org/binutils/docs/as/index.html">GNU Manual: Using as</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
