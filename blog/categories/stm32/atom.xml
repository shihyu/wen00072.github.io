<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Stm32 | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/stm32/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2016-08-06T08:41:39+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (3): USART 初探]]></title>
    <link href="http://wen00072.github.io/blog/2016/08/05/arm-cm4-pratice-3-lab-usart/"/>
    <updated>2016-08-05T15:53:47+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/08/05/arm-cm4-pratice-3-lab-usart</id>
    <content type="html"><![CDATA[<h2>致謝</h2>

<p>感謝網友<a href="https://github.com/starnight">Zack</a>，<a href="http://vh21.github.io/">Villar</a>，學弟Joe Ho，還有其他大大的幫忙，不然這次應該是撞牆撞到死吧。</p>

<h2>前言</h2>

<p>這次實驗有卡關，不然其實不算難。卡關的點如下：</p>

<ul>
<li>一開始使用USART1，可是USART1接到STLink 接腳，最後用USART6代替。(<a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F4 Discovry Disco 開發版手冊</a>，p19, SB11那段)</li>
<li>SPL的HSE 設定和版子不合，造成Baud rate計算錯誤。</li>
</ul>


<p>這次的實驗是一個ECHO程式，透過版子上的USART6和電腦連線，電腦送出什麼字元，版子就傳回什麼字元。</p>

<h2>目錄</h2>

<ul>
<li><a href="#stm-3-prepare">事前準備</a></li>
<li><a href="#stm-3-env">測試環境</a></li>
<li><a href="#stm-3-usart">USART 控制</a></li>
<li><a href="#stm-3-code">程式碼</a>

<ul>
<li><a href="#stm-3-code-code">完整程式碼</a></li>
<li><a href="#stm-3-code-make">Makefile</a></li>
</ul>
</li>
<li><a href="#stm-3-test">功能驗證</a></li>
<li><a href="#stm-3-ref">參考資料</a></li>
</ul>


<p><a name="stm-3-prepare"></a></p>

<h2>事前準備</h2>

<ul>
<li><p>Saleae 邏輯分析儀 (一千新台幣有找）</p>

<ul>
<li>需要自行到Saleae官方網站下載安裝Linux版軟體
<img src="http://wen00072.github.io/files/stm32/STM_LG.jpg"/></li>
</ul>
</li>
<li><p>USB 轉 RS232 TTL 轉接線
<img src="http://wen00072.github.io/files/banana_pi/DSC_0026.jpg"/></p></li>
</ul>


<p><a name="stm-3-env"></a></p>

<h2>測試環境</h2>

<pre><code class="text">$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.4 LTS
Release:    14.04
Codename:   trusty

$ arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-branch revision 237715]
...
</code></pre>

<ul>
<li>SPL版本： STM32F4xx_DSP_StdPeriph_Lib_V1.6.1</li>
<li>開發板： STM32F4 Dicovery, <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F429-Disco</a></li>
</ul>


<p><a name="stm-3-usart"></a></p>

<h2>USART 控制</h2>

<p>對於組裝工來說，我想要理解的不是電位差之這些電器信號。甚至在組裝時我也不在意暫存器設定等東西和背後的原理（好孩子不要學）。我關心的是</p>

<ol>
<li>我們要用哪些資源？</li>
<li>這些資源對應的實體腳位是？</li>
<li>軟體中怎麼樣設定和啟動設備？</li>
<li>軟體中怎麼樣傳輸資料？</li>
</ol>


<p>我們針對這四個問題一一處理</p>

<h3>我們要用哪些資源？</h3>

<p>從手冊可以看到有八個USART可以用。我原本是挑USART1來用，不過後來卡關經過網友提醒發現要避開USART1。後來發現APB2上面除了USART1外另外一個USART是USART6。懶得太多程式碼的情況下就挑了USART6。</p>

<h3>這些資源對應的實體腳位是？</h3>

<p>一樣要翻手冊。</p>

<ul>
<li>PC6: UASRT6 TX</li>
<li>PC7: USART6 RX</li>
</ul>


<h3>軟體中怎麼樣設定和啟動設備？</h3>

<p>要分兩個部份討論</p>

<h4>a. GPIOC 設定</h4>

<p>要設定</p>

<ul>
<li>開啟GPIOC的clock</li>
<li>設定Pin腳，設定PC6和PC7這兩個腳位。為什麼是這兩個腳位請查手冊

<ul>
<li>PC6: 設成Alternate function，也就是USART6 TX</li>
<li>PC7: 設成Alternate function，也就是USART6 RX</li>
<li>其他

<ul>
<li>設定為Pull UP，這和USART通訊協定有關，在IDLE時維持高電位</li>
<li>設定Push-Pull輸出模式，這個我完全不懂只是閉著眼睛抄的</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>來看大家最討厭看的程式碼片斷吧</p>

<pre><code class="c">    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable GPIOC clock */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

    /* Connect USART6_Tx instead of PC6 */
    GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_USART6);

    /* Connect USART6_Rx instead of PC7 */
    GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);

    /* Configure USART Tx (PC6) and Rx (PC7) as alternate function  */
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;

    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);
</code></pre>

<h4>b. USART6 設定</h4>

<p>依下列步驟</p>

<ol>
<li>開啟USART6的clock</li>
<li>設定USART6

<ul>
<li>115200 BPS</li>
<li>No parity bit</li>
<li>8-bit 資料</li>
<li>1 Stop bit</li>
<li>關閉硬體流量控制</li>
<li>TX/RX模式都打開</li>
</ul>
</li>
<li>啟動UASRT6</li>
</ol>


<p>一樣來看大家最討厭看的程式碼片斷吧</p>

<pre><code class="c">    USART_InitTypeDef USART_InitStruct;

    /* Enable USART6 clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);

    /* 115200, N81  */
    USART_InitStruct.USART_BaudRate = 115200;
    USART_InitStruct.USART_WordLength = USART_WordLength_8b;
    USART_InitStruct.USART_StopBits = USART_StopBits_1;
    USART_InitStruct.USART_Parity = USART_Parity_No;
    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Apply USART settings */
    USART_Init(USART6, &amp;USART_InitStruct);

    /* Enable USART */
    USART_Cmd(USART6, ENABLE);
</code></pre>

<h3>軟體中怎麼樣傳輸資料？</h3>

<p>這部份還蠻直覺的，就是檢查狀態。可以送的時候就寫資料到暫存器去；有資料時從暫存器讀出資料。程式碼夠短應該不會那麼討厭吧？另外SPL也有提供USART傳輸接收的函數，請自行查詢。</p>

<pre><code class="c">
char getchar(void)
{
    while(USART_GetFlagStatus(USART6, USART_FLAG_RXNE) == RESET);
    return USART6-&gt;DR &amp; 0xff;
}

void putchar(char c)
{
    /* Wait until data was tranferred */
    while(USART_GetFlagStatus(USART6, USART_FLAG_TXE) == RESET);

    USART6-&gt;DR = (c &amp; 0xff);
}
</code></pre>

<p><a name="stm-3-code"></a></p>

<h2>程式碼</h2>

<p>最完整可編譯程式碼放在<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/tree/master/labs/1_usart">這邊</a>。</p>

<p>前面有提到HSE設定需要更動為8MHz。我是在<code>stm32f4xx_conf.h</code>加入以下片斷。</p>

<pre><code class="c">
#if defined  (HSE_VALUE)
/* Redefine the HSE value; it's equal to 8 MHz on the STM32F4-DISCOVERY Kit */
 #undef HSE_VALUE
 #define HSE_VALUE    ((uint32_t)8000000) 
#endif /* HSE_VALUE */
</code></pre>

<p><a name="stm-3-code-code"></a></p>

<h3>完整程式碼</h3>

<p>就是把前面的設定合體再加上一些helper就是了。這個程式也不難，就是印出你打的字。當你按enter後會自動塞入<code>\r</code>並且印出提示符號。</p>

<pre><code class="c usart.c">#include "stm32f4xx_conf.h"
#include &lt;stm32f4xx.h&gt;
#include &lt;stm32f4xx_gpio.h&gt;
#include &lt;stm32f4xx_usart.h&gt;

void setupUSART(void);

/* helper functions */
void print(char *str);
char getchar(void);
void putchar(char c);

int main(int argc, char **argv)
{
    /* Setup USART */
    setupUSART();

    /* Greeting */
    print("Hello World\n");
    print("\r&gt; ");
    while(1) {
        /* Echo a character */
        char c = getchar();
        putchar(c);

        /* Show prompt with enter */
        if (c == '\n') {
            print("\r&gt; ");
        }
    }

    return 0;
}

void setupUSART(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable GPIOC clock */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

    /* Connect USART6_Tx instead of PC6 */
    GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_USART6);

    /* Connect USART6_Rx instead of PC7 */
    GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);

    /* Configure USART Tx (PC6) and Rx (PC7) as alternate function  */
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;

    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

    /********************************************
     * USART set started here
     ********************************************/
    USART_InitTypeDef USART_InitStruct;

    /* Enable USART6 clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);

    /* 115200, N81  */
    USART_InitStruct.USART_BaudRate = 115200;
    USART_InitStruct.USART_WordLength = USART_WordLength_8b;
    USART_InitStruct.USART_StopBits = USART_StopBits_1;
    USART_InitStruct.USART_Parity = USART_Parity_No;
    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    /* Apply USART settings */
    USART_Init(USART6, &amp;USART_InitStruct);

    /* Enable USART */
    USART_Cmd(USART6, ENABLE);
}

char getchar(void)
{
    while(USART_GetFlagStatus(USART6, USART_FLAG_RXNE) == RESET);
    return USART6-&gt;DR &amp; 0xff;
}

void putchar(char c)
{
    /* Wait until data was tranferred */
    while(USART_GetFlagStatus(USART6, USART_FLAG_TXE) == RESET);

    USART6-&gt;DR = (c &amp; 0xff);
}

void print(char *str)
{
    assert_param(str != 0);
    while(*str) {
        putchar(*str);
        str++;
    }
}

/* Trap here for gdb if asserted */
void assert_failed(uint8_t* file, uint32_t line)
{
    while(1);
}
</code></pre>

<p><a name="stm-3-code-make"></a></p>

<h3>Makefile</h3>

<p>有兩點要說明</p>

<ol>
<li>加入<code>stm32f4xx_usart.c</code></li>
<li>加入make flash自動燒錄

<ul>
<li>目前發現使用st-flash燒錄有時候顯示燒錄完成，但是實際上測試還是燒錄前的行為，換成openocd測試中</li>
</ul>
</li>
</ol>


<pre><code class="Makefile">#----------------------------------------------------------------------------------
# Commom settings
#----------------------------------------------------------------------------------
TARGET=usart
PRJ_ROOT=$(shell cd ../../ ; pwd)
include $(PRJ_ROOT)/conf/build.def

#----------------------------------------------------------------------------------
# Files to build
#----------------------------------------------------------------------------------
SRCS  = $(CMSIS_STARTUP_SRC) $(CMSIS_SYSTEM_SRC)
SRCS += $(STM_DIR)/src/stm32f4xx_gpio.c
SRCS += $(STM_DIR)/src/stm32f4xx_rcc.c
SRCS += $(STM_DIR)/src/stm32f4xx_usart.c
SRCS += usart.c

C_OBJS = $(patsubst %.c, %.o, $(SRCS))   # translate *.c to *.o
OBJS   = $(patsubst %.s, %.o, $(C_OBJS)) # also *.s to *.o files

OUT_OBJS = $(addprefix $(OUT_DIR)/, $(OBJS))

#----------------------------------------------------------------------------------
# Build here
#----------------------------------------------------------------------------------
$(OUT_DIR)/$(TARGET).bin: $(OUT_OBJS)
    $(TOOL_CHAIN_PREFIX)-gcc -Wl,-Map=$(OUT_DIR)/$(TARGET).map,-T$(TARGET).ld -nostartfiles \
        $(CFLAGS) $(OUT_OBJS) -o $(OUT_DIR)/$(TARGET).elf
    $(TOOL_CHAIN_PREFIX)-objcopy -Obinary $(OUT_DIR)/$(TARGET).elf $@
    $(TOOL_CHAIN_PREFIX)-objdump -S $(OUT_DIR)/$(TARGET).elf &gt; $(OUT_DIR)/$(TARGET).list

$(OUT_DIR)/%.o: %.s
    mkdir -p $(dir $@)
    $(TOOL_CHAIN_PREFIX)-gcc -c $(CFLAGS) $&lt; -o $@

$(OUT_DIR)/%.o: %.c
    mkdir -p $(dir $@)
    $(TOOL_CHAIN_PREFIX)-gcc -c $(CFLAGS) $&lt; -o $@

flash: $(OUT_DIR)/$(TARGET).bin
    openocd -f interface/stlink-v2.cfg  \
            -f target/stm32f4x.cfg      \
            -c "init"                   \
            -c "reset init"             \
            -c "stm32f2x unlock 0"      \
            -c "flash probe 0"          \
            -c "flash info 0"           \
            -c "flash write_image erase $&lt; 0x8000000" \
            -c "reset run" -c shutdown

clean:
    rm -fr $(OUT_DIR) gdb.txt
</code></pre>

<p><a name="stm-3-test"></a></p>

<h2>功能驗證</h2>

<h3>邏輯分析儀驗證</h3>

<p>現在邏輯分析儀已經可以自動幫你抓波形分析了。當你下載並解壓縮檔案後，記得更新udev的Rule讓電腦可以認得邏輯分析儀。</p>

<p>接下來你要設定邏輯分析儀的分析通訊協定為Async Serial 如下圖
<img src="http://wen00072.github.io/files/stm32/LG_SP1.jpg"/></p>

<p>選了Async Serial會有選單出現，你需要設定用第幾個Channel以及USART通訊參數如下圖
<img src="http://wen00072.github.io/files/stm32/LG_SP2.jpg"/></p>

<p>如果需要的話，你可以進一步設定取樣速度、取樣時間如下圖
<img src="http://wen00072.github.io/files/stm32/LG_SP3.jpg"/></p>

<p>假設你的邏輯分析儀接腳都接好了就可以按開始分析訊號了
<img src="http://wen00072.github.io/files/stm32/LG_SP4.jpg"/></p>

<p>這是一個成功的Hello World波形分析，圖可能有點小，全圖在<a href="/files/stm32/usart2.jpg">這邊</a>。
<img src="http://wen00072.github.io/files/stm32/usart2.jpg"/></p>

<h3>實際驗證</h3>

<p>你需要先把USB 轉 RS232 TTL 轉接線接到版子上如下圖
<img src="http://wen00072.github.io/files/stm32/STM_USART_Pin.jpg"/></p>

<p>我是使用mintern，執行畫面如下</p>

<pre><code class="text">$ miniterm.py -b 115200 -p /dev/ttyUSB0 
--- Miniterm on /dev/ttyUSB0: 115200,8,N,1 ---
--- Quit: Ctrl+]  |  Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
test
&gt; test
&gt; test
&gt; test
&gt; testast
&gt; teadsatdsasd
</code></pre>

<p><a name="stm-3-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://homes.soic.indiana.edu/geobrown/index.cgi/teaching">Geoffrey Brown: Teaching </a>

<ul>
<li>請找 Lab Manual 裏面的link, 書名是<code>Discovering the STM32 Microcontroller</code></li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F4 Discovry Disco 開發版手冊</a></li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">STM32F4 DSP and standard peripherals library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (2): 實驗軟體專案規劃和LED閃滅實驗]]></title>
    <link href="http://wen00072.github.io/blog/2016/06/27/arm-cm4-pratice-2-lab-led/"/>
    <updated>2016-06-27T19:14:27+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/06/27/arm-cm4-pratice-2-lab-led</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>閉著眼睛學東西最困擾的是資料很多，但是完全不知道怎麼從那邊下手。這次運氣很好終於找到大大推荐的<a href="http://homes.soic.indiana.edu/geobrown/index.cgi/teaching">入門教材: Discovering the STM32 Microcontroller</a>作為一個突破點。雖然他上面講的是STM32F1，不過改一下還是可以在開發版上面動，短期內的自學大概會以這本書為主。</p>

<p>本篇文章主要是介紹在GNU/Linux下的STM32F429　開發軟體，這次以LED閃滅為實習題目，以後的實習會基於這次的專案為主。有興趣的朋友請自行到我的<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice">Github repository</a>取用。注意是這個專案單純自爽，常常會<code>git push -f</code>變動commit，如果有人fork我再調整。</p>

<h2>目錄</h2>

<ul>
<li><a href="#STM-ENV">測試環境</a></li>
<li><a href="#STM_PRJ">專案規劃</a></li>
<li><a href="#STM_MK">Makefile撰寫</a>

<ul>
<li><a href="#STM_MK_COMM">共用變數</a></li>
<li><a href="#STM_MK_TEMP">專案Makefile template</a></li>
</ul>
</li>
<li><a href="#STM_LED">第一支程式: LED閃滅</a>

<ul>
<li><a href="#STM_LED_LK_STRP">Linker script 和 start up檔案</a></li>
<li><a href="#STM_LED_GPIO">GPIO API</a></li>
<li><a href="#STM_LED_TIMER_ISR">Timer ISR</a></li>
<li><a href="#STM_LED_CODE">程式碼</a></li>
<li><a href="#STM_LED_VERIFY">燒錄和測試</a></li>
</ul>
</li>
<li><a href="#STM-SPL-REF">參考資料</a></li>
</ul>


<p><a name="STM-ENV"></a></p>

<h2>測試環境</h2>

<pre><code class="text">$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.4 LTS
Release:    14.04
Codename:   trusty

$ arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-branch revision 237715]
...
</code></pre>

<ul>
<li>SPL版本： STM32F4xx_DSP_StdPeriph_Lib_V1.6.1</li>
<li>開發板： STM32F4 Dicovery, <a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F429-Disco</a></li>
<li>SPL 目錄架構</li>
</ul>


<pre><code class="text">$ tree -d -L 4
.
└── STM32F4xx_DSP_StdPeriph_Lib_V1.6.1
    ├── _htmresc
    ├── Libraries
    │   ├── CMSIS
    │   │   ├── Device
    │   │   ├── Documentation
    │   │   ├── DSP_Lib
    │   │   ├── Include
    │   │   ├── Lib
    │   │   └── RTOS
    │   └── STM32F4xx_StdPeriph_Driver
    │       ├── inc
    │       └── src
    ├── Project
    │   ├── STM32F4xx_StdPeriph_Examples
    │   └── STM32F4xx_StdPeriph_Templates
    └── Utilities
        ├── Media
        ├── ST
        ├── STM32_EVAL
        └── Third_Party
</code></pre>

<p><a name="STM_PRJ"></a></p>

<h2>專案規劃</h2>

<p>看<a href="http://www.cs.indiana.edu/~geobrown/book.pdf">Discovering the STM32 Microcontroller</a>這本書後啟發的。想法整理如下：</p>

<ul>
<li>目的：建立一個練習STM32F4開發版的專案</li>
<li>專案需要的資料

<ul>
<li>STM 函式庫 source code

<ul>
<li>這部份要去官方網站下載，不會放到github上面</li>
</ul>
</li>
<li>Build code 共用的設定如toolchain、路徑、compile flag等</li>
<li>一些template 檔案加入開發如Makefile、linker script、config header file</li>
</ul>
</li>
</ul>


<p>最後的目錄就是這樣。</p>

<pre><code class="text ">$ tree -L 3
.
├── conf
│   ├── build.def
│   ├── Makefile.template
│   ├── stm32f4xx_conf.h
│   └── template-bared.ld
├── labs
│   └── 0_led
│       ├── led.c
│       ├── led.ld
│       ├── Makefile
│       └── stm32f4xx_conf.h
├── libraries
│   ├── readme.txt
│   └── STM32F4xx_DSP_StdPeriph_Lib_V1.6.1
├── LICENSE
└── README.md
</code></pre>

<p>請注意SPL可能會因為下載版本不同，變數宣告、常數宣告、和檔案名稱路徑可能不同造成編譯失敗，這時候就當組裝作業自己解決吧。</p>

<p><a name="STM_MK"></a></p>

<h2>Makefile撰寫</h2>

<p><a name="STM_MK_COMM"></a></p>

<h3>共用變數</h3>

<p>這邊我們需要一個共用的設定，在實習的時候直接include。詳細說明如下，懶得看的可以直接看<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/conf/build.def">檔案內容</a>。</p>

<ul>
<li><p>Toolchain設定</p>

<ul>
<li>安裝請參考<a href="http://wen00072.github.io/blog/2016/04/06/arm-cm4-pratice-0-environment-setup/">這邊</a>
<code>Makefile
TOOL_CHAIN_PREFIX=arm-none-eabi
</code></li>
</ul>
</li>
<li><p>路徑設定</p>

<ul>
<li>我們需要<strong>定位</strong>專案的最頂端位址才能設定其他路徑的相對位址</li>
<li>除了您自己的檔案，ST 提供的函式庫和ARM的CMSIS在開發都會用到</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">PRJ_ROOT?=..
LIB_DIR=$(PRJ_ROOT)/libraries/STM32F4xx_DSP_StdPeriph_Lib_V1.6.1/Libraries
STM_DIR=$(LIB_DIR)/STM32F4xx_StdPeriph_Driver
CMSIS_DIR=$(LIB_DIR)/CMSIS
LDSCRIPT?=$(PRJ_ROOT)/conf/bared.ld
</code></pre>

<ul>
<li><p>指定開發平台
<code>Makefile
PLATFORM = STM32F429_439xx
</code></p></li>
<li><p>設定header file路徑
<code>Makefile
SPL_INC=$(STM_DIR)/inc
CMSIS_COMMON_INC = $(CMSIS_DIR)/Include
CMSIS_STM32_INC  = $(CMSIS_DIR)/Device/ST/STM32F4xx/Include
</code></p></li>
<li><p>指令所有產生的檔案都放到build目錄
<code>Makefile
OUT_DIR=$(PRJ_ROOT)/build
</code></p></li>
<li><p>設定start up檔案和system檔案路徑
除非你要自己從flash搬資料到RAM、設定ISR vector、RCC等，不然一定會用到start up 檔案和system檔案。start up 檔案在SPL中有很多範本，我們使用了<code>gcc_ride7</code>這個版本，原因是其他的都沒有<code>gcc</code>這個字眼。
<code>Makefile
CMSIS_STARTUP_SRC = $(CMSIS_DIR)/Device/ST/STM32F4xx/Source/Templates/gcc_ride7/startup_stm32f429_439xx.s
CMSIS_SYSTEM_SRC  = $(CMSIS_DIR)/Device/ST/STM32F4xx/Source/Templates/system_stm32f4xx.c
</code></p></li>
<li><p>設定debug mode
SPL提供assertion，使用USE_FULL_ASSERT打開。打開以後需要自行實作函數<code>void assert_failed(uint8_t* file, uint32_t line)</code>。</p></li>
</ul>


<pre><code class="Makefile">BUILD_MODE = DEBUG

ifeq ($(BUILD_MODE), DEBUG)
        CFLAGS += -DUSE_FULL_ASSERT -g3
endif
</code></pre>

<ul>
<li><p>CPU相關compile flags
STM32F4使用Cotex M4。題外話，對於toolchain有興趣的可以用<code>arm-none-eabi-gcc -Q --help=target</code>查詢有支援哪些平台。
<code>Makefile
ARCH_FLAGS = -mthumb -mcpu=cortex-m4
</code></p></li>
<li><p>Compile flag分為</p>

<ul>
<li>增加嚴格的錯誤檢查</li>
<li>設定include 路徑</li>
<li>叫toolchain不要用使用內建的函式庫如libc</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">LDFLAGS += -T$(LDSCRIPT) $(ARCH_FLAGS)

CFLAGS += $(ARCH_FLAGS)
CFLAGS += -I. -I$(SPL_INC) -I$(CMSIS_COMMON_INC) -I$(CMSIS_STM32_INC)
CFLAGS += -D$(PLATFORM) -DUSE_STDPERIPH_DRIVER $(FULLASSERT)
CFLAGS += -Wall -Werror -MMD -std=c99
CFLAGS += -fno-common -ffreestanding -O0
</code></pre>

<p><a name="STM_MK_TEMP"></a></p>

<h3>專案Makefile template</h3>

<p>這邊直接把LED閃滅的Makefile拿來當template，詳細說明如下，一樣懶得看的可以去<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/conf/Makefile.template">這邊</a>看檔案內容。</p>

<ul>
<li>產生的binary 檔名、定位專案的最頂端位址、並且載入<a href="#STM_MK_COMM">前面</a>的設定檔。</li>
</ul>


<pre><code class="Makefile">TARGET=led
PRJ_ROOT=$(shell cd ../../ ; pwd)
include $(PRJ_ROOT)/conf/build.def
</code></pre>

<ul>
<li><p>指定要編譯的SPL 檔案
除了前面<a href="#STM_MK_COMM">前面</a>提到的start up檔案、system檔、還有你自己的程式碼外，根據你的需求，還會需要SPL的驅動程式。這個專案我們需要<code>GPIO</code>和<code>RCC</code> (reset clock control)這兩個部份。一個是用來控制LED、另外一個用來計算時間產生以控制閃滅。
<code>Makefile
SRCS  = $(CMSIS_STARTUP_SRC) $(CMSIS_SYSTEM_SRC)
SRCS += $(STM_DIR)/src/stm32f4xx_gpio.c
SRCS += $(STM_DIR)/src/stm32f4xx_rcc.c
SRCS += led.c
</code></p></li>
<li><p>檔名轉換
上面的是source檔案，但是我們編譯需要把source檔案轉成object檔案並且存在./build目錄下。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Makefile'><span class='line'><span class="nv">C_OBJS</span> <span class="o">=</span> <span class="k">$(</span>patsubst %.c, %.o, <span class="k">$(</span>SRCS<span class="k">))</span>   <span class="c"># translate &lt;em&gt;.c to &lt;/em&gt;.o</span>
</span><span class='line'><span class="nv">OBJS</span>   <span class="o">=</span> <span class="k">$(</span>patsubst %.s, %.o, <span class="k">$(</span>C_OBJS<span class="k">))</span> <span class="c"># also &lt;em&gt;.s to &lt;/em&gt;.o files&lt;/p&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="err">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span><span class="nv">OUT_OBJS</span> <span class="o">=</span> <span class="k">$(</span>addprefix <span class="k">$(</span>OUT_DIR<span class="k">)</span>/, <span class="k">$(</span>OBJS<span class="k">))</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>產生led.bin
不要被符號嚇到，說明如下</p>

<ul>
<li>產生build/led.bin檔，前提是上面的object 檔案都編譯完成</li>
<li>產生方式

<ul>
<li>叫gcc 從前面的object檔案中，透過led.ld linker script產生出build/led.elf、build/led.map (debug用)</li>
<li>從build/led.elf產生build/led.bin</li>
<li>從build/led.elf產生build/led.list (debug用)</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="Makefile">$(OUT_DIR)/$(TARGET).bin: $(OUT_OBJS)
    $(TOOL_CHAIN_PREFIX)-gcc -Wl,-Map=$(OUT_DIR)/$(TARGET).map,-T$(TARGET).ld -nostartfiles \
        $(CFLAGS) $(OUT_OBJS) -o $(OUT_DIR)/$(TARGET).elf
    $(TOOL_CHAIN_PREFIX)-objcopy -Obinary $(OUT_DIR)/$(TARGET).elf $@
    $(TOOL_CHAIN_PREFIX)-objdump -S $(OUT_DIR)/$(TARGET).elf &gt; $(OUT_DIR)/$(TARGET).list
</code></pre>

<ul>
<li>編譯並產生object 檔案
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Makefile'><span class='line'><span class="nf">$(OUT_DIR)/%.o</span><span class="o">:</span> %.<span class="n">s</span>
</span><span class='line'>  @mkdir -p <span class="k">$(</span>dir <span class="nv">$@</span><span class="k">)</span>
</span><span class='line'>  <span class="k">$(</span>TOOL_CHAIN_PREFIX<span class="k">)</span>-gcc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&amp;</span>lt<span class="p">;</span> -o <span class="nv">$@</span>&lt;/li&gt;
</span><span class='line'><span class="err">&lt;/ul&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;p&gt;$(OUT_DIR)/%.o</span><span class="o">:</span> %.<span class="n">c</span>
</span><span class='line'>    @mkdir -p <span class="k">$(</span>dir <span class="nv">$@</span><span class="k">)</span>
</span><span class='line'>    <span class="k">$(</span>TOOL_CHAIN_PREFIX<span class="k">)</span>-gcc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&amp;</span>lt<span class="p">;</span> -o <span class="nv">$@</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>以下不解釋
<code>Makefile
clean:
  rm -fr $(OUT_DIR) gdb.txt
</code></li>
</ul>


<p><a name="STM_LED"></a></p>

<h2>第一支程式: LED閃滅</h2>

<p><a name="STM_LED_LK_STRP"></a></p>

<h3>Linker script 和 start up檔案</h3>

<h4>Linker script</h4>

<p>linker script (<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/labs/0_led/led.ld">全文</a>)，這個script是從<a href="http://wiki.csie.ncku.edu.tw/embedded/rtenv">成大課程作業</a>修改的，簡單解釋如下</p>

<ul>
<li>有兩塊記憶體，一個是FLASH一個是RAM，FLASH 不可寫入。</li>
<li>那些<code>.text</code>、<code>.data</code>、<code>.bss</code>就不解釋了。我們這次關注下列的symbols

<ul>
<li><code>_sidata</code></li>
<li><code>_sdata</code></li>
<li><code>_edata</code></li>
<li><code>_sbss</code></li>
<li><code>_ebss</code></li>
<li><code>_estack</code></li>
</ul>
</li>
</ul>


<h4>Start up檔案</h4>

<p>上面的這些symbol，可以<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S">對照</a>這邊的start up 程式碼中的<code>reset_handler</code>，可以發現：</p>

<ul>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L49">第49行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L57">第57行</a>就宣告了這些symbol</li>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L76">第76行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L89">第89行</a>使用了這些symbol將FLASH中的<code>.data</code>資料搬到<code>RAM</code>中</li>
<li><a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L89">第90行</a> 到 <a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L100">第100行</a>使用了這些symbol將<code>.bss</code>區段的值全部設成0</li>
</ul>


<p>搞定<code>.bss</code>和<code>.data</code>後，接下來start up會去<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L103">呼叫systemInit</a>，而<code>systemInit</code>就在<code>system_stm32f4xx.c</code>裏面。設定完系統後就是你寫的程式碼<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L105">main</a>上場了。</p>

<p>start up 檔案剩下的部份就是<a href="https://github.com/jserv/stm32f429-r3d/blob/master/startup_stm32f429_439xx.S#L128">.isr_vector</a>，可以想像成一個function pointer陣列(除了最開始的stack pointer，注意stack pointer初始值也是在linker script中設定的)。</p>

<p>另外一個要注意的是start up source code的順序和放在記憶體的順序不一致，真正在記憶體的順序請參考<a href="https://github.com/zzz0072/STM32F429-Discovery-Disco-Pratice/blob/master/labs/0_led/led.ld">linker script</a>。
<a name="STM_LED_GPIO"></a></p>

<h3>GPIO API</h3>

<p>設定順序如下</p>

<ul>
<li>看<a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">開發版手冊</a>找出要控制燈號的GPIO

<ul>
<li>我程式就是輪流點亮點滅LED 3和LED 4，手冊上說是GPIO G的第13和14腳位</li>
</ul>
</li>
<li>打開GPIO的clock（猜測嵌入式系統的電耗考慮，沒再用的設備都不開clock省電）</li>
<li>設定GPIO腳位的為輸出頻率為2MHz</li>
</ul>


<pre><code class="c GPIO設定">void setupLED(GPIO_InitTypeDef *LED_InitStruct)
{
    /* Setup LED GPIO */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);

    GPIO_StructInit(LED_InitStruct);
    LED_InitStruct-&gt;GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_14 ;
    LED_InitStruct-&gt;GPIO_Mode  = GPIO_Mode_OUT;
    LED_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_Init(GPIOG, LED_InitStruct);
}
</code></pre>

<ul>
<li>輸出資料到GPIO範例如下
<code>c 輸出資料到GPIO範例
  GPIO_WriteBit(GPIOG, GPIO_Pin_13 , 1);
</code></li>
</ul>


<p><a name="STM_LED_TIMER_ISR"></a></p>

<h3>Timer ISR</h3>

<p>要做的是</p>

<ul>
<li><p>設定timer interrupt 出現的週期，設定成nano second的程式碼如下
<code>c
  /* Setup timer interrupt interval to nano second */
  if(SysTick_Config(SystemCoreClock / 1000)) {
      while(1); /* Trap here if failed */
  }   
</code></p></li>
<li><p>time out的ISR，基本上就是計數counter加上busy waiting而已
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">__IO</span> <span class="kt">uint32_t</span> <span class="n">g_timeToWakeUp</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">sleep</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">nSec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">g_timeToWakeUp</span> <span class="o">=</span> <span class="n">nSec</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Busy</span> <span class="n">waiting</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">g_timeToWakeUp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<p><a name="STM_LED_CODE"></a></p>

<h3>程式碼</h3>

<p>這邊的assertion 實作單純是一個無限迴圈，當assertion失敗就會陷入這個迴圈。這時候用除錯器就可以找到出現assertion的行號了。</p>

<p>寫了以後開始修改程式碼或<code>Makefile</code>直到編譯過以後才針對程式行為除錯。</p>

<pre><code class="c led.c">#include "stm32f4xx_conf.h"
#include &lt;stm32f4xx.h&gt;
#include &lt;stm32f4xx_gpio.h&gt;

/* A Led blink lab for STM32 Discovry Disco                   *
 * Based on:                                                  *
 *   Discovering the STM32 Microcontroller by Geoffrey Brown. */

void setupLED(GPIO_InitTypeDef *LED_InitStruct);
void sleep(uint32_t nSec);

int main(int argc, char **argv)
{
    static int LEDVal = 0;
    GPIO_InitTypeDef LED_InitStruct;

    /* Setup LED */
    setupLED(&amp;LED_InitStruct);

    /* Setup timer interrupt interval to nano second */
    if(SysTick_Config(SystemCoreClock / 1000)) {
        while(1); /* Trap here if failed */
    }

    /* Blinking LED3 and LED4 */
    while(1) {
        GPIO_WriteBit(GPIOG, GPIO_Pin_13 , LEDVal);
        GPIO_WriteBit(GPIOG, GPIO_Pin_14 , !LEDVal);

        sleep(250);
        LEDVal = !LEDVal;
    }

    return 0;
}

void setupLED(GPIO_InitTypeDef *LED_InitStruct)
{
    /* Setup LED GPIO */
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);

    GPIO_StructInit(LED_InitStruct);
    LED_InitStruct-&gt;GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_14 ;
    LED_InitStruct-&gt;GPIO_Mode  = GPIO_Mode_OUT;
    LED_InitStruct-&gt;GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_Init(GPIOG, LED_InitStruct);
}

static __IO uint32_t g_timeToWakeUp;
void sleep(uint32_t nSec)
{
    g_timeToWakeUp = nSec;

    /* Busy waiting */
    while(g_timeToWakeUp != 0);
}

/* ISR for system tick */
void SysTick_Handler(void)
{
    if (g_timeToWakeUp != 0x00) {
        g_timeToWakeUp--;
    }
}

/* Trap here for gdb if asserted */
void assert_failed(uint8_t* file, uint32_t line)
{
    while(1);
}
</code></pre>

<p>比較有趣的是<code>int LEDVal = 0;</code>一定要宣告成<code>static</code>，否則LED完全沒反應。在網路上請教似乎和進出ISR的時候context備份有關係，這部份有空再找時間了解一下，這次先跳過。</p>

<ul>
<li>更新，後來測試不管是沒有<code>static</code>，把<code>static</code>改成<code>volatile</code>，都出現第一次燒錄行為不正常，多燒幾次又正常的情況。需要再重新釐清。</li>
</ul>


<p><a name="STM_LED_VERIFY"></a></p>

<h3>燒錄和測試</h3>

<ul>
<li><p>直接在工作目錄下執行make
<code>text
STM32F429-Discovery-Disco-Pratice/labs/0_led$ make
arm-none-eabi-gcc -c -DUSE_FULL_ASSERT -g3 -mthumb -mcpu=cortex-m4 -I. -I../../libraries/STM32F4xx_DSP_StdPeriph_Lib_V1.6.1/Libraries/STM32F4xx_StdPeriph_Driver/inc -I../../libraries/
...
arm-none-eabi-objcopy -Obinary ../../build/led.elf ../../build/led.bin
arm-none-eabi-objdump -S ../../build/led.elf &gt; ../../build/led.list
</code></p></li>
<li><p>燒錄指令如下
<code>text
STM32F429-Discovery-Disco-Pratice/labs/0_led$ st-flash write ../../build/led.bin  0x8000000
2016-07-25T11:31:28 INFO src/stlink-common.c: Loading device parameters....
2016-07-25T11:31:28 INFO src/stlink-common.c: Device connected is: F42x and F43x device, id 0x10036419
...
enabling 32-bit flash writes
size: 11596
2016-07-25T11:31:28 INFO src/stlink-common.c: Starting verification of write complete
2016-07-25T11:31:29 INFO src/stlink-common.c: Flash written and verified! jolly good!
</code></p></li>
</ul>


<p>以下是LED點亮結果</p>

<center><img src="http://wen00072.github.io/files/stm32/STM_LED.jpg"></img></center>


<p><a name="STM-SPL-REF"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://homes.soic.indiana.edu/geobrown/index.cgi/teaching">Geoffrey Brown: Teaching </a>

<ul>
<li>請找 Lab Manual 裏面的link, 書名是<code>Discovering the STM32 Microcontroller</code></li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-eval-tools/stm32-mcu-eval-tools/stm32-mcu-discovery-kits/32f429idiscovery.html">STM32F4 Discovry Disco 開發版手冊</a></li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">STM32F4 DSP and standard peripherals library</a></li>
<li><a href="http://regalis.com.pl/en/arm-cortex-stm32-gnulinux/">Programming ARM Cortex (STM32) under GNU/Linux</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM CM4 Pratice (1): STM32 F4xx Standard Peripherals Library手冊整理]]></title>
    <link href="http://wen00072.github.io/blog/2016/06/25/stm32-f4xx-standard-peripherals-libraryshou-ce-zheng-li/"/>
    <updated>2016-06-25T14:03:46+08:00</updated>
    <id>http://wen00072.github.io/blog/2016/06/25/stm32-f4xx-standard-peripherals-libraryshou-ce-zheng-li</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>以前在寫作業的時候，從來沒有想過那些週邊到底怎麼使用，只大概印象和<a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a>有關。後來想應該是要去了解到底這些廠商提供的函式庫在軟體開發中扮演了什麼樣的角色？因此花了時間整理如下。</p>

<p>在使用之前，請自行到<a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">官方網站</a>下載STM32F4 DSP and standard peripherals library。</p>

<h2>目錄</h2>

<ul>
<li><a href="#AST-%E7%B0%A1%E4%BB%8B">簡介</a>

<ul>
<li><a href="#AST-CMSIS">CMSIS和Standard Peripherals Library說明</a></li>
</ul>
</li>
<li><a href="#AST-Rules">Coding rules and conventions</a>

<ul>
<li><a href="#AST-Rules-general">一般命名規則</a></li>
<li><a href="#AST-Rules-reg">週邊 Register 命名規則</a></li>
</ul>
</li>
<li><a href="#AST-Ref">參考資料</a></li>
</ul>


<p><a name="AST-簡介"></a></p>

<h2>簡介</h2>

<p>手冊上提到Standard Peripherals Library (以下簡稱SPL)的特點</p>

<ul>
<li>提供STM32F4 XX的週邊驅動程式和常用的資料結構</li>
<li>基於CMSIS開發</li>
<li>ANSI C開發</li>
<li>使用SPL表示週邊設備存取效能和佔用的記憶體空間是由SPL決定，因此有特別限制的話必須要自行最佳化或是實作</li>
</ul>


<p>SPL包含:</p>

<ul>
<li>週邊設備暫存器的位址mapping，包含這些暫存器的bit</li>
<li>所有週邊的控制function以及對應的資料結構</li>
<li>範例程式</li>
</ul>


<p><a name="AST-CMSIS"></a></p>

<h3>CMSIS和Standard Peripherals Library說明</h3>

<p>整體的架構圖如下(參考手冊資料）</p>

<center><img src="http://wen00072.github.io/files/stm32/SPL_Diag.jpg"></img></center>


<p>簡單說明如下</p>

<ul>
<li>CMSIS 提供了

<ul>
<li>統一的暫存器定義、位址定義</li>
<li>協助開發的函數</li>
<li>RTOS 介面</li>
<li>DSP 相關函數</li>
</ul>
</li>
<li>開發版上實體的週邊驅動程式是透過SPL和CMSIS來控制硬體</li>
</ul>


<p><a name="AST-Rules"></a></p>

<h2>Coding rules and conventions</h2>

<p><a name="AST-Rules-general"></a></p>

<h3>一般命名規則</h3>

<ul>
<li>函數名稱以<strong>大寫週邊簡寫</strong>為prefix如<code>USART_SendData</code></li>
<li>文件舉例的API，請自行望文生義

<ul>
<li><code>週邊名稱_Init</code></li>
<li><code>週邊名稱_DeInit</code></li>
<li><code>週邊名稱_StructInit</code></li>
<li><code>週邊名稱_Cmd</code></li>
<li><code>週邊名稱_ITConfig</code>

<ul>
<li>IT: interrupt</li>
</ul>
</li>
<li><code>週邊名稱_DMAConfig</code></li>
<li><code>週邊名稱_XXXConfig</code>

<ul>
<li>週邊設備的XXX設定</li>
</ul>
</li>
<li><code>週邊名稱_GetFlagStatus</code></li>
<li><code>週邊名稱_ClearFlag</code></li>
<li><code>週邊名稱_ClearITPendingBit</code></li>
</ul>
</li>
</ul>


<p><a name="AST-Rules-reg"></a></p>

<h3>週邊 Register 命名規則</h3>

<ul>
<li>週邊 Register 一律包裝在<code>struct</code>中，名稱一律為大寫。在 stm32f4xx.h 另外已經宣告了週邊設備位址的結構如：</li>
</ul>


<pre><code class="c">#define SPI1                  ((SPI_TypeDef *) SPI1_BASE)
</code></pre>

<p><code>SPI_TypeDef</code>為一個struct，因此你可以使用下面方式直接存取週邊設備暫存器。</p>

<pre><code class="c">SPI1-&gt;CR1 = 0x0001;
</code></pre>

<p>有了大概概念後，接下來就是開幹時間，敬請期待。</p>

<p><a name="AST-Ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32065.html">STM32F4 DSP and standard peripherals library</a>

<ul>
<li>本篇絕大部分參考解開套件後的stm32f4xx_dsp_stdperiph_lib_um.chm　這個文件檔案</li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-embedded-software/stm32cubef4.html">STM32CubeF4網頁</a>

<ul>
<li>有SPL的相關資料</li>
</ul>
</li>
<li><a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32-standard-peripheral-libraries/stsw-stm32062.html">STM32F2 standard peripherals library手冊</a>

<ul>
<li>交叉比對用</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
