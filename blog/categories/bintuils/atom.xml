<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Bintuils | My code works, I don't know why.]]></title>
  <link href="http://wen00072.github.io/blog/categories/bintuils/atom.xml" rel="self"/>
  <link href="http://wen00072.github.io/"/>
  <updated>2016-08-02T17:39:49+08:00</updated>
  <id>http://wen00072.github.io/</id>
  <author>
    <name><![CDATA[Wen Liao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[談談C語言的全域變數和 Linux Object 檔案的關係]]></title>
    <link href="http://wen00072.github.io/blog/2014/12/09/global-variables-from-common-symbol-on-the-c-programming-language/"/>
    <updated>2014-12-09T03:04:00+08:00</updated>
    <id>http://wen00072.github.io/blog/2014/12/09/global-variables-from-common-symbol-on-the-c-programming-language</id>
    <content type="html"><![CDATA[<p>印象中以前學過C語言中跨檔案的全域變數是這樣宣告的。
檔案一：<code>int g_var1;</code>
檔案二：<code>extern int g_val1;</code></p>

<p>然而，我從來沒有想過如果沒有extern的情況會發生什麼狀況。加上之前看過的objdump和nm後手癢，所以把可能的排列組合看看可能發生什麼事。</p>

<p>這邊要先知道common object表示object檔案已經紀錄下這個symbol，最後link的時候才會決定要怎麼處理。會放在common section <a href="http://stackoverflow.com/questions/18335256/what-does-com-stand-for-in-objdump-symbol-table">出處</a>。</p>

<p>由於結果和分析又臭又長，連我自己都不太想回去看。建議先看<a href="#elf-concl">結論</a>，有疑惑再回來看結果和分析吧。</p>

<h2>目錄</h2>

<ul>
<li><a href="#elf-env">測試環境</a></li>
<li><a href="#elf-ex">測試程式</a></li>
<li><a href="#elf-res">測試結果</a></li>
<li><a href="#elf-concl">結論</a></li>
<li><a href="#elf-ref">參考資料</a></li>
</ul>


<p><a name="elf-env"></a></p>

<h2>測試環境</h2>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.1 LTS
Release:    14.04
Codename:   trusty
</code></pre>

<ul>
<li>GNU objdump (GNU Binutils for Ubuntu) 2.24</li>
<li>GNU nm (GNU Binutils for Ubuntu) 2.24</li>
</ul>


<p><a name="elf-ex"></a></p>

<h2>測試程式</h2>

<p>非常簡單，就是有兩個檔案存放全域變數，每次測試時先更改全域變數
* 是否有初始值
* 宣告方式是否有<code>extern</code>
全部的排列組合放在<a href="#elf-res">這邊</a></p>

<pre><code class="c var1.c">int g_var1;
</code></pre>

<pre><code class="c var2.c">int g_var1;
</code></pre>

<pre><code class="c main.c">#include &lt;stdio.h&gt;
extern int g_var1;
int main()
{
    printf("Hello %d\n", g_var1);
    return 0;
}
</code></pre>

<pre><code class="makefile Makefile">TARGET=glvar
SRCS=var_1.c var_2.c main.c
OBJS=$(patsubst %.c, %.o, $(SRCS))
CFLAGS=-g

$(TARGET): $(OBJS)
    $(CC) -o $@ $^

test: $(TARGET)
    objdump -t $(OBJS) $(TARGET)
    nm -A $(OBJS) $(TARGET)
    ./$(TARGET)

clean:
    rm -f $(TARGET) $(OBJS)
</code></pre>

<p><a name="elf-res"></a></p>

<h2>測試結果</h2>

<table>
<thead>
<tr>
<th> var1.c 宣告方式         </th>
<th> var2.c宣告方式         </th>
<th> 編譯結果  </th>
<th style="text-align:right;"> nm 和 objdump 分析  </th>
</tr>
</thead>
<tbody>
<tr>
<td> int g_var;            </td>
<td> int g_var;            </td>
<td>  成功     </td>
<td style="text-align:right;"> <a href="#elf-res1">分析</a>  </td>
</tr>
<tr>
<td> int g_var = 2;        </td>
<td> int g_var;            </td>
<td>  成功     </td>
<td style="text-align:right;"> <a href="#elf-res2">分析</a>  </td>
</tr>
<tr>
<td> int g_var;            </td>
<td> int g_var = 3;        </td>
<td>  成功     </td>
<td style="text-align:right;"> <a href="#elf-res3">分析</a>  </td>
</tr>
<tr>
<td> int g_var = 2;        </td>
<td> int g_var = 3;        </td>
<td>  失敗     </td>
<td style="text-align:right;"> <a href="#elf-res4">分析</a>  </td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th> var1.c 宣告方式         </th>
<th> var2.c宣告方式             </th>
<th> 編譯結果  </th>
<th style="text-align:right;"> nm 和 objdump 分析  </th>
</tr>
</thead>
<tbody>
<tr>
<td> int g_var;            </td>
<td> extern <br>int g_var;     </td>
<td> 成功      </td>
<td style="text-align:right;"> <a href="#elf-res5">分析</a>  </td>
</tr>
<tr>
<td> int g_var = 2;        </td>
<td> extern <br>int g_var;     </td>
<td> 成功      </td>
<td style="text-align:right;"> <a href="#elf-res6">分析</a>  </td>
</tr>
<tr>
<td> int g_var;            </td>
<td> extern <br>int g_var = 3; </td>
<td> 有警告    </td>
<td style="text-align:right;"> <a href="#elf-res7">分析</a>  </td>
</tr>
<tr>
<td> int g_var = 2;        </td>
<td> extern <br>int g_var = 3; </td>
<td> 失敗      </td>
<td style="text-align:right;"> <a href="#elf-res8">分析</a>  </td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th> var1.c 宣告方式            </th>
<th> var2.c宣告方式              </th>
<th> 編譯結果  </th>
<th style="text-align:right;"> nm 和 objdump 分析  </th>
</tr>
</thead>
<tbody>
<tr>
<td> extern <br>int g_var;     </td>
<td> extern <br>int g_var;     </td>
<td> link失敗  </td>
<td style="text-align:right;"> <a href="#elf-res9">分析</a>  </td>
</tr>
<tr>
<td> extern <br>int g_var = 2; </td>
<td> extern <br>int g_var;     </td>
<td> 有警告    </td>
<td style="text-align:right;"> <a href="#elf-res10">分析</a>  </td>
</tr>
<tr>
<td> extern <br>int g_var      </td>
<td> extern <br>int g_var = 3; </td>
<td> 有警告    </td>
<td style="text-align:right;"> <a href="#elf-res11">分析</a>  </td>
</tr>
<tr>
<td> extern <br>int g_var = 2; </td>
<td> extern <br>int g_var = 3; </td>
<td> link失敗  </td>
<td style="text-align:right;"> <a href="#elf-res12">分析</a>  </td>
</tr>
</tbody>
</table>


<p><a name="elf-res1"></a></p>

<h2>分析 var1.c: int g_var; var2.c: int g_var; 的結果</h2>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000004       O <em>COM</em>  0000000000000004 g_var1

<ul>
<li>這是一個object，放在commom section</li>
</ul>
</li>
<li>var2.o: 0000000000000004       O <em>COM</em>  0000000000000004 g_var1

<ul>
<li>這是一個object，放在commom section。</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: 0000000000601044 g     O .bss   0000000000000004              g_var1

<ul>
<li>這個symbol放在<code>.bss</code>，也就是未初始化的全域變數</li>
<li>這是最後產生的executable object</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000004 C g_var1

<ul>
<li>這是一個common symbol。</li>
</ul>
</li>
<li>var_2.o:0000000000000004 C g_var1

<ul>
<li>這是一個common symbol。</li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: <code>glvar:0000000000601044 B g_var1</code>

<ul>
<li>這是最後產生的executable object</li>
<li>這個symbol放在<code>.bss</code>，也就是未初始化的全域變數</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res2"></a></p>

<h2>分析 var1.c: int g_var = 2; var2.c: int g_var; 的結果</h2>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 0000000000000004       O <em>COM</em>  0000000000000004 g_var1

<ul>
<li>這是一個object，放在commom section</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: 0000000000601040 g     O .data   0000000000000004              g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
<li>這是最後產生的executable object</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o:0000000000000004 C g_var1

<ul>
<li>這是一個common symbol。</li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar:0000000000601040 D g_var1

<ul>
<li>這是最後產生的executable object</li>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res3"></a></p>

<h2>分析 var1.c: int g_var2 = 2; var2.c:  int g_var; 的結果</h2>

<p>和上面的差別只有var1.o和var2.o的結果對調而已。</p>

<p><a name="elf-res4"></a></p>

<h2>分析 var1.c: int g_var2 = 2; var2.c:  int g_var = 3; 的結果</h2>

<ul>
<li>錯誤訊息： g_var1重複定義</li>
</ul>


<pre><code>$ make test
cc -g   -c -o var_1.o var_1.c
cc -g   -c -o var_2.o var_2.c
cc -g   -c -o main.o main.c
cc -o glvar var_1.o var_2.o main.o
var_2.o:(.data+0x0): multiple definition of `g_var1'
var_1.o:(.data+0x0): first defined here
collect2: error: ld returned 1 exit status
make: *** [glvar] Error 1
</code></pre>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res5"></a></p>

<h2>分析 var1.c: int g_var; var2.c: extern int g_var; 的結果</h2>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000004       O <em>COM</em>  0000000000000004 g_var1

<ul>
<li>這是一個object，放在commom section</li>
</ul>
</li>
<li>var2.o: 沒有g_var1這個entry</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: 0000000000601040 g     O .data   0000000000000004              g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
<li>這是最後產生的executable object</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000004 C g_var1

<ul>
<li>這是一個common symbol</li>
</ul>
</li>
<li>var_2.o: 沒有symbol</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar:0000000000601040 B g_var1

<ul>
<li>這是最後產生的executable object</li>
<li>這個symbol是全域變數，並且放在沒有初始值的資料section</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res6"></a></p>

<h2>分析 var1.c: int g_var = 2; var2.c: extern int g_var; 的結果</h2>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 沒有g_var1這個entry</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: 0000000000601040 g     O .data   0000000000000004              g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
<li>這是最後產生的executable object</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o: 沒有symbol</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar:0000000000601040 D g_var1

<ul>
<li>這是最後產生的executable object</li>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res7"></a></p>

<h2>分析 var1.c: int g_var; var2.c: extern int g_var = 3; 的結果</h2>

<ul>
<li>得到警告和錯誤：</li>
</ul>


<pre><code>$ make test
rm -f glvar  var_1.o  var_2.o  main.o
cc -g   -c -o var_1.o var_1.c
cc -g   -c -o var_2.o var_2.c
var_2.c:1:12: warning: ‘g_var1’ initialized and declared ‘extern’ [enabled by default]
 extern int g_var1 = 3;
            ^
cc -g   -c -o main.o main.c
cc -o glvar var_1.o var_2.o main.o
var_2.o:(.data+0x0): multiple definition of `g_var1'
var_1.o:(.data+0x0): first defined here
collect2: error: ld returned 1 exit status
make: *** [glvar] Error 1
</code></pre>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000004       O <em>COM</em>  0000000000000004 g_var1

<ul>
<li>這是一個object，放在commom section</li>
</ul>
</li>
<li>var2.o: <strong>0000000000000000 g     O .data    0000000000000004 g_var1</strong>

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> sectio</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar: 0000000000601040 g     O .data   0000000000000004              g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
<li>這是最後產生的executable object</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這是一個common symbol</li>
</ul>
</li>
<li>var_2.o:0000000000000000 D g_var1

<ul>
<li><strong>這個symbol是全域變數，並且放在有初始值的資料section</strong></li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
<li>glvar:0000000000601040 D g_var1

<ul>
<li>這是最後產生的executable object</li>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res8"></a></p>

<h2>分析 var1.c: int g_var = 2; var2.c: extern int g_var = 3; 的結果</h2>

<ul>
<li>得到警告和link錯誤：</li>
</ul>


<pre><code>$  make test
cc -g   -c -o var_1.o var_1.c
cc -g   -c -o var_2.o var_2.c
var_2.c:1:12: warning: ‘g_var1’ initialized and declared ‘extern’ [enabled by default]
 extern int g_var1 = 3;
            ^
cc -g   -c -o main.o main.c
cc -o glvar var_1.o var_2.o main.o
var_2.o:(.data+0x0): multiple definition of `g_var1'
var_1.o:(.data+0x0): first defined here
collect2: error: ld returned 1 exit status
make: *** [glvar] Error 1
</code></pre>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res9"></a></p>

<h2>分析 var1.c: extern int g_var; var2.c: extern int g_var; 的結果</h2>

<ul>
<li><p>link時發生錯誤
<code>
$ make test
cc -g   -c -o var_1.o var_1.c
cc -g   -c -o var_2.o var_2.c
cc -g   -c -o main.o main.c
cc -o glvar var_1.o var_2.o main.o
main.o: In function `main':
/home/wen/work/practice/Linux_Programming_Practice/16_global_var/main.c:5: undefined reference to `g_var1'
collect2: error: ld returned 1 exit status
make: *** [glvar] Error 1
</code></p></li>
<li><p><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：</p>

<ul>
<li>var1.o: 沒有g_var這個 entry</li>
<li>var2.o: 沒有g_var這個 entry</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o: 沒有symbol</li>
<li>var_2.o: 沒有symbol</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res10"></a></p>

<h2>分析 var1.c: extern int g_var = 2; var2.c: extern int g_var; 的結果</h2>

<ul>
<li>得到警告：</li>
</ul>


<pre><code>var_1.c:1:12: warning: ‘g_var1’ initialized and declared ‘extern’ [enabled by default]
</code></pre>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 沒有g_var這個 entry</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o: 沒有symbol</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-res11"></a></p>

<h2>分析 var1.c: extern int g_var2; var2.c: extern int g_var = 3; 的結果</h2>

<p>和上面的差別只有var1.o和var2.o的結果對調而已。</p>

<p><a name="elf-res12"></a></p>

<h2>分析 var1.c: extern int g_var2 = 2; var2.c: extern int g_var = 3; 的結果</h2>

<ul>
<li>得到警告和錯誤：</li>
</ul>


<pre><code>$ make clean ; make test
rm -f glvar  var_1.o  var_2.o  main.o
cc -g   -c -o var_1.o var_1.c
var_1.c:1:12: warning: ‘g_var1’ initialized and declared ‘extern’ [enabled by default]
 extern int g_var1 = 2;
            ^
cc -g   -c -o var_2.o var_2.c
var_2.c:1:12: warning: ‘g_var1’ initialized and declared ‘extern’ [enabled by default]
 extern int g_var1 = 3;
            ^
cc -g   -c -o main.o main.c
cc -o glvar var_1.o var_2.o main.o
var_2.o:(.data+0x0): multiple definition of `g_var1'
var_1.o:(.data+0x0): first defined here
collect2: error: ld returned 1 exit status
make: *** [glvar] Error 1
</code></pre>

<ul>
<li><code>objdump -t</code> 顯示object檔案的symbol table欄位資料：

<ul>
<li>var1.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>var2.o: 0000000000000000 g     O .data  0000000000000004 g_var1

<ul>
<li>這是一個全域變數物件，放在有初始值的<code>.data</code> section</li>
</ul>
</li>
<li>main.o: 0000000000000000         <em>UND</em>  0000000000000000 g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
<li><code>nm -A</code> 顯示object檔案的symbol：

<ul>
<li>var_1.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>var_2.o:0000000000000000 D g_var1

<ul>
<li>這個symbol是全域變數，並且放在有初始值的資料section</li>
</ul>
</li>
<li>main.o:                 U g_var1

<ul>
<li>這是一個undefined symbol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a name="elf-concl"></a></p>

<h2>結論</h2>

<ul>
<li>common symbol表示object檔案已經紀錄下這個symbol，先放在common section。最後link的時候才會決定要怎麼處理。 <a href="http://stackoverflow.com/questions/18335256/what-does-com-stand-for-in-objdump-symbol-table">出處</a></li>
<li><code>gcc -c</code>產生的object檔案中未初始化的全域變數會放在common section而不是<code>.bss</code> section，原因是link時期其他的object可能有相同名稱的symbol，而這些相同的symbol可能有初始化也可能沒有。而linker需要全盤了解後再做出決定要放在<code>.bss</code>還是<code>.data</code> section。</li>
<li>最後link出來的executable object檔案不會有common symbol</li>
<li>多個檔案宣告同樣名稱的全域變數時，編譯時會依下面的情況處理

<ul>
<li>超過兩個檔案有設初始值，噴錯誤</li>
<li>都沒設定初始值，產生的object檔案放common section。link時放<code>.bss</code> section。</li>
<li>一個檔案有設定初始值，其他沒有設定初始值的情形

<ul>
<li>有設定初始值那個檔案的object檔案變數放在<code>.data</code></li>
<li>其他沒有設定初始值有設定初始值那個檔案的object檔案變數放在common section</li>
<li>link時放<code>.data</code> section</li>
</ul>
</li>
</ul>
</li>
<li>使用<code>extern</code>全域變數的時候

<ul>
<li>程式碼沒用到該全域變數在未link前的object 檔案不會有該symbol</li>
<li>程式碼用到該全域變數在未link前的object 檔案該symbol為undefined</li>
<li>程式碼給初始值會產生警告，並且會被新增到該object 檔案的symbol table，以至於其他檔案宣告該全域變數會產生重複定義的錯誤。</li>
</ul>
</li>
</ul>


<p><a name="elf-ref"></a></p>

<h2>參考資料</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/18335256/what-does-com-stand-for-in-objdump-symbol-table">stackoverflow: What does <em>COM</em> stand for in objdump symbol table?</a></li>
<li><a href="http://www.slideshare.net/lubatang/singleton-constructor">從 Singleton 談 constructor</a></li>
<li><a href="http://stackoverflow.com/questions/16835716/bss-vs-common-what-goes-where">stackoverflow: .bss vs COMMON: what goes where?</a></li>
<li><a href="http://swaywang.blogspot.tw/2012/06/elfbss-sectioncommon-section.html">Sw@y&rsquo;s Notes: ELF中的.bss section和COMMON section</a></li>
<li><a href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts">GNU linker ld: Linker Scripts</a></li>
<li><code>man nm</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux中使用C語言載入data Object 檔案資料 (續）]]></title>
    <link href="http://wen00072.github.io/blog/2014/04/16/load-linux-using-c-language-data-object-archives-data-continued/"/>
    <updated>2014-04-16T02:01:00+08:00</updated>
    <id>http://wen00072.github.io/blog/2014/04/16/load-linux-using-c-language-data-object-archives-data-continued</id>
    <content type="html"><![CDATA[<h2>動機</h2>

<p><a href="http://wen00072.github.io/blog/2014/04/15/loads-the-data-object-using-the-c-language-archives-data-in-linux">前面</a>討論了Linux中使用C語言載入data object 檔案資料，裏面提到資料轉成object，裏面會有三個symbol: <code>_binary_objfile_start</code>, <code>_binary_objfile_end</code>, <code>_binary_objfile_size</code>。</p>

<h2>Object symbol</h2>

<p><code>man objcopy</code>找<code>_size</code>可以看到
<code>text
       -B bfdarch
       --binary-architecture=bfdarch
           Useful when transforming a architecture-less input file into an object file.  In this case the output architecture can be set to bfdarch.  This
           option will be ignored if the input file has a known bfdarch.  You can access this binary data inside a program by referencing the special
           symbols that are created by the conversion process.  These symbols are called _binary_objfile_start, _binary_objfile_end and
           _binary_objfile_size.  e.g. you can transform a picture file into an object file and then access it in your code using these symbols.
</code></p>

<h2>測試: Segmentation fault版</h2>

<p>簡單來說，和平台無關的檔案轉成obj檔時，可以透過<code>_binary_objfile_start</code>, <code>_binary_objfile_end</code>, <code>_binary_objfile_size</code>去存取資料。所以我再修改了一下測試程式，印出這些symbol 的內容</p>

<pre><code class="c test_obj.c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_CHARS (32)

extern char _binary_my_data_txt_start;
extern char _binary_my_data_txt_end;
extern int _binary_my_data_txt_size;

int main(int argc, char **argv)
{
    char line[MAX_CHARS] = {0};
    char *my_data_start_addr = (char *) &amp;_binary_my_data_txt_start;
    int str_len = (char) *my_data_start_addr - 0x30; /* 0x30 =&gt; '0' */

    if (str_len &gt; MAX_CHARS) {
        str_len = MAX_CHARS;
    }

    strncpy(line, my_data_start_addr + 1, str_len);

    printf("_binary_my_data_txt_start: %c\n", _binary_my_data_txt_start);
    printf("_binary_my_data_txt_end: %c\n", _binary_my_data_txt_end);
    printf("_binary_my_data_txt_size: %d\n", _binary_my_data_txt_size);
    printf("Read string is %s\n", line);

    return 0;
}
</code></pre>

<p>而測試檔案為
<code>text my_data.txt
5Hello
</code></p>

<p>一跑起來會發生Segmentation fault如下
<code>
$ ./test_obj
_binary_my_data_txt_start: 5
_binary_my_data_txt_end:
Segmentation fault (core dumped)
</code></p>

<h2>分析</h2>

<p>使用gdb可以看到當在存取<code>_binary_my_data_txt_size</code>這行，我們還可以進一步來看這個<strong>變數</strong></p>

<pre><code class="text gdb 結果">_binary_my_data_txt_start: 5
_binary_my_data_txt_end: 

Program received signal SIGSEGV, Segmentation fault.
main (argc=1, argv=0x7fffffffe1d8) at test_obj.c:24
24      printf("_binary_my_data_txt_size: %d\n", _binary_my_data_txt_size);
(gdb) p _binary_my_data_txt_size
Cannot access memory at address 0x7
</code></pre>

<p>疑？變數位址是0x7?那我把測試檔案內容改一下，增加3個字元，再跑一次gdb。</p>

<pre><code class="text my_data.txt">8HelloABC
</code></pre>

<pre><code class="text gdb 結果">(gdb) p _binary_my_data_txt_size
Cannot access memory at address 0xa
</code></pre>

<p>可以看到位址從<code>0x7</code>跑到<code>0xa</code>，也就是10，這表示這個數字增加三了。這讓我懷疑這個symbol並不是一個變數，而是一個數值。因此我們可以將
* <code>printf("_binary_my_data_txt_size: %d\n", _binary_my_data_txt_size);</code></p>

<pre><code>改成
</code></pre>

<ul>
<li><code>printf("_binary_my_data_txt_size: %p\n", &amp;_binary_my_data_txt_size);</code></li>
</ul>


<p>另外一個有趣的地方是<code>_binary_my_data_txt_end</code>並不是<code>C</code>，而是<code>\0</code>。而<code>_binary_my_data_txt_end</code>前一個字元是<code>\n</code>。使用<code>ghex</code>去看my_data.txt可以看到最後一個資料其實是<code>\n</code>。但是<code>\0</code>怎麼出現的，目前還不清楚。</p>

<h2>參考資料</h2>

<ul>
<li><code>man objcopy</code></li>
<li><a href="http://bytbox.net/blog/2012/11/linking-raw-data.html">Linking raw data with C code</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux中使用C語言載入data Object 檔案資料]]></title>
    <link href="http://wen00072.github.io/blog/2014/04/15/loads-the-data-object-using-the-c-language-archives-data-in-linux/"/>
    <updated>2014-04-15T16:20:00+08:00</updated>
    <id>http://wen00072.github.io/blog/2014/04/15/loads-the-data-object-using-the-c-language-archives-data-in-linux</id>
    <content type="html"><![CDATA[<p>之前看<a href="https://github.com/southernbear/rtenv">別人的程式</a>，看到作者在ROMFS實作時把資料轉成object檔案，然後在C語言中直接存取資料。他的作法是</p>

<ul>
<li>寫一個host程式，將某個目錄下面的檔案和目錄轉成單一個binary</li>
<li>將這個binary轉成object檔案</li>
<li>更改link script，讓最後的binary可以存取object檔案的section</li>
</ul>


<p>這個project使ARM的架構Realtime 作業系統。看完手癢也想看看Linux下面要怎麼做到類似的功能。本來想說是不是要動到link script，後來看到<a href="http://descent-incoming.blogspot.tw/2012/11/elf.html">這邊</a>的參考資料後，發現只要存取symbol就可以使用了。克服這個問題後就可以來寫個小程式驗證一下。</p>

<p>首先我們先弄個測試資料，很簡單就是一個數字顯示後面字串長度後再存放字串。
<code>text my_data.txt
5Hello
</code></p>

<p>接下來就是Makefile部份</p>

<pre><code class="makefile Makefile">CFLAGS=-Wall -Werror -g

DATA_SRC=my_data.txt
DATA_OBJ=my_data.o

TARGET=test_obj
OBJS=$(patsubst %, %.o, $(TARGET)) $(DATA_OBJ)

BFN=elf64-x86-64
ARCH=i386

$(TARGET): $(OBJS)
    $(CC) -o $@ $(OBJS)

$(DATA_OBJ): $(DATA_SRC)
    objcopy -I binary -O $(BFN) -B $(ARCH) --prefix-sections '.mydata' $^ $@

clean:
    rm *.o *~ $(TARGET) -f
</code></pre>

<p>Makefile說明:
* <code>patsubst</code>
    * Makefile 提供的函數，用在pattern 替換，所以上面做了下列的代換
    * test_obj轉成test_obj.o
* <code>$@</code>
    * Makefile的內建巨集，代表target
* <code>$^</code>
    * Makefile的內建巨集，代表prerequisite</p>

<p>重點是把資料檔案轉成object的部份，節錄該部份並說明如下
<code>objcopy -I binary -O $(BFN) -B $(ARCH) --prefix-sections '.mydata' $^ $@</code></p>

<ul>
<li><code>-I binary</code>

<ul>
<li>指定input檔案binary格式為binary</li>
</ul>
</li>
<li><code>-O elf64-x86-64</code>

<ul>
<li>指定output binary 格式為elf64-x86-64</li>
</ul>
</li>
<li><code>-B i386</code>

<ul>
<li>指定架構為i386</li>
</ul>
</li>
<li><code>--prefix-sections '.mydata'</code>

<ul>
<li>指定放在.mydata的section</li>
</ul>
</li>
</ul>


<p>至於要怎麼知道binary格式和架構呢？您可以用<code>objcopy --info |less</code>配合<code>file test_obj.o</code>找出平台上的參數。</p>

<p>我們先來看一下section是不是真的放到.mydata?
<figure class='code'><figcaption><span>objdump結果</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>$ objdump -h my_data.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;my_data.o:     file format elf64-x86-64&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Sections:
</span><span class='line'>Idx Name          Size      VMA               LMA               File off  Algn
</span><span class='line'>  0 .mydata.data  00000007  0000000000000000  0000000000000000  00000040  2**0
</span><span class='line'>                  CONTENTS, ALLOC, LOAD, DATA
</span></code></pre></td></tr></table></div></figure></p>

<p>我只知道.mydata的section，裏面的資訊目前還不清楚有什麼意義。</p>

<p>我們再用nm來看檔案內有哪些symbol</p>

<pre><code class="text nm結果">$ nm  my_data.o
0000000000000007 D _binary_my_data_txt_end
0000000000000007 A _binary_my_data_txt_size
0000000000000000 D _binary_my_data_txt_start
</code></pre>

<p>flag說明
* <code>D</code>
    * 資料放在初始的資料section
* <code>A</code>
    * Symbol的值已固定，之後link也不會更動。目前還不知道這樣透露出有什麼額外的資訊</p>

<p>接下來就是存取的方式了，測試程式如下。主要就是從section讀出字串再印出來。</p>

<pre><code class="c test_obj.c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_CHARS (32)

extern char _binary_my_data_txt_start;
int main(int argc, char **argv)
{
    char line[MAX_CHARS] = {0};
    char *my_data_start_addr = (char *) &amp;_binary_my_data_txt_start;
    int str_len = (char) *my_data_start_addr - 0x30; /* 0x30 =&gt; '0' */

    if (str_len &gt; MAX_CHARS) {
        str_len = MAX_CHARS;
    }

    strncpy(line, my_data_start_addr + 1, str_len);

    printf("Read string is %s\n", line);

    return 0;
}
</code></pre>

<p>程式說明如下
* 前面nm看到的symbol <code>_binary_my_data_txt_end</code>, <code>_binary_my_data_txt_start</code>, 和<code>_binary_my_data_txt_size</code>只是一個sybmol，這邊我們存的是字元所以宣告成<code>char</code>
* _binary_my_data_txt_start存放的是該section開始的資料，我們可以用gdb驗證一下</p>

<pre><code class="text gdb 節錄">Breakpoint 1, main (argc=1, argv=0x7fffffffe1d8) at test_obj.c:10
10      char *my_data_start_addr = (char *) &amp;_binary_my_data_txt_start;
(gdb) p _binary_my_data_txt_start
$1 = 53 '5'
</code></pre>

<ul>
<li>所以我們可以取得該資料位址後，讀出字串長度後，再複製後面的字串並列印出來。</li>
</ul>


<p>最後執行結果如下
&#8220;`text 執行結果
$ ./test_obj
Read string is Hello</p>

<p>&#8220;`</p>

<h2>參考資料</h2>

<ul>
<li><a href="https://github.com/southernbear/rtenv">rtenv</a></li>
<li><a href="http://descent-incoming.blogspot.tw/2012/11/elf.html">將檔案系統塞到 elf 執行檔</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
